---
site:
  title: Projet BAO
  categorie: Margaux Duhayon
  description: Projet de traitement automatique des langues, utilisant Perl et XSLT

author:
  all: Milena Chaîne, Margaux Duhayon, Ferial Yahiaoui
  milena: Milena Chaîne
  margaux: Margaux Duhayon
  ferial: Ferial Yahiaoui
  school: Inalco

master:
  site: "http://www.tal.univ-paris3.fr/plurital/"


layout: margaux

---

<% content_for :logo do %>
<%= image_tag "test3.jpg" %>
<% end %>

<h1>
  <%= current_page.data.site.title %>
</h1>


<%= link_to(
  current_page.data.author.milena,
  "milena.html",
  target: "_blank"
) %>
<%= link_to(
  current_page.data.author.margaux,
  "margaux.html",
  target: "_blank"
) %>
<%= link_to(
  current_page.data.author.ferial,
  "ferial.html",
  target: "_blank"
) %>

<h2>
  <%= current_page.data.site.categorie %>
</h2>

<%= partial "partials/onglet_bao_margaux" %>

<p>INTRODUCTION</p>

<h3>BAO 1 </h3>
<p> La Boîte à outil n°1 permet de parcourir les rubriques des chacunes des archives du <em>Monde</em> afin de récupérer les titres et les descriptions de chaque article et les mettre dans 2 fichiers :
un fichier texte et un fichier xml. <br/>Les données récupérées sont également nettoyer dans cette boîte à outil. <br/>Nous observerons les résultats dans la boîte à outil n°2 qui possède seulement un sous-programme d'étiquetage supplémentaire. </p>

<label>

<%= partial "partials/code", :locals => { :code_file => "assets/margaux/BAO1_margaux.pl"} %>
<% code("perl") do %>
#/usr/bin/perl
<<DOC;
BAO 1 Margaux Duhayon
Commande : perl BAO1.pl repertoire-a-parcourir rubrique


#------------------------ BAO1 ----------------------------------

#--------- Définition des variables et entête du fichier xml-------------------------------

my $rep="$ARGV[0]";
my $rubrique="$ARGV[1]";
my %dico= ();

$rep=~ s/[\/]$//; # le nom du répertoire ne doit pas se termine pas par un "/"

open my $sortie_txt,">:encoding(utf8)", "$rubrique.txt"; #sortie qui sera un fichier txt
open my $sortie_xml,">:encoding(utf8)", "$rubrique.xml"; # sortie qui sera un fichier xml
print $sortie_xml "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n"; #entête du futur fichier xml
print $sortie_xml "<PARCOURS>\n";
print $sortie_xml "<NOM>Duhayon Margaux</NOM>\n";
print $sortie_xml "<ABSTRACT>\n";


&parcoursarborescencefichiers($rep);	# on lance la récursion

print $sortie_xml "</ABSTRACT>\n";
print $sortie_xml "</PARCOURS>\n";

close $sortie_txt;
close $sortie_xml;

exit;

#----------------Ouverture des fichier ------------------------------

sub parcoursarborescencefichiers {
    my $path = shift(@_);
    opendir(DIR, $path) or die "can't open $path: $!\n";
    my @files = readdir(DIR);
    closedir(DIR);
    foreach my $file (@files) {
		next if $file =~ /^\.\.?$/;
		$file = $path."/".$file;
		if (-d $file) {
			print "<NOUVEAU REPERTOIRE> ==> ",$file,"\n";
			&parcoursarborescencefichiers($file);	#recurse!
			print "<FIN REPERTOIRE> ==> ",$file,"\n";
		}

#---------------- Si c'est un fichier xml : récuperer le texte ------------------------------

		if (-f $file) {
            if($file =~ m/$rubrique.+\.xml$/) {

                print "<",$i++,"> ==> ",$file,"\n";

                open my $FILEIN, "<:encoding(utf-8)", $file;

                my $ensemble="";
                while (my $ligne=<$FILEIN>) {
                    chomp $ligne;
                    $ligne =~ s/\r//g;
                    $ensemble = $ensemble . $ligne ;
                }

#----------------Chercher les balises titre et description ------------------------------

                while ($ensemble =~ m/<item>.*?<title>(.+?)<\/title>.*?<description>(.+?)<\/description>.*?<\/item>/g){
                    my $title = $1;
                    my $description = $2;
                    if (!exists $dico{$title})
                        {
                        $dico{$title} = 1;
                        my ($titre_propre, $description_propre) = &nettoyage($title, $description);

#---------------- Impression du contenu dans des balises ------------------------------

                        print $sortie_txt "$titre_propre.\n";
                        print $sortie_txt "$description_propre\n\n";

                        print $sortie_xml "<item><titre>$titre_propre</titre><description>$description_propre</description></item>\n";

          }
        }
      }
		}
  }
}

#------------ Sous-programme de nettoyage -------------------

sub nettoyage {
    my $var1 = shift(@_); # @_: liste des arguemnts d'une procédure
    my $var2 = shift(@_);
    my $var3 = shift(@_);
    my $var4 = shift(@_);
    my $var5 = shift(@_);
    my $var6 = shift(@_);
    my $var7 = shift(@_);

    $var1 =~s/&lt;.+?&gt;//g;
    $var2 =~s/&lt;.+?&gt;//g;
    $var3 =~ s/&#38;#39;/'/g;
    $var4 =~ s/&#039;/'/g;
    $var5 =~ s/\t+//g;
    $var6 =~ s/> +</></g;
    $var7 =~ s/<[^>]+?>//g;
    return $var1,$var2,$var3,$var4,$var5,$var6,$var7;
}
<% end %>
</label>

<h3>BAO 2 </h3>
<p> La Boîte à outil n°2 effectue la même action que la Boîte à outil n°1 mais possède une étape supplémentaire qui est l'étiquetage des titres et descriptions.
</p>

<label>

<%= partial "partials/code", :locals => { :code_file => "assets/margaux/BAO2_margaux.pl"} %>
<% code("perl") do %>



<% end %>
</label>

<h3>BAO 3 </h3>

<p>La Boîte à outil n°3 permet d'extraire des patrons morphosyntaxiques dans les étiquetages produits avec Cordial. </p>
<p> Plusieurs possibilités seront présentées :
<br/><br/> 1) une solution perl qui prend en argument le fichier texte des patrons
<br/> 2) une solution avec l'aide de recommandation XSLT
<br/> 3) une solution avec l'aide de recommandation XQUERY

</p>

<h4> 1 ère solution :</h4>
<p>Pour cette solution, il faut dans un premier temps, passer les fichiers étiquetés obtenus dans la BAO 2 dans le logiciel <em>Cordial</em>.
<br/> Le programme va parcourir le fichier ligne par ligne et va mettre dans 3 listes différentes le contenu de chacune des colonnes du fichier Cordial.
<br/>On a également besoin d'un fichier texte avec les patrons morphosyntaxiques comme ci-dessous.</p>
<p> Pour passer les fichiers dans <em>Cordial</em>, il faut modiffier l'encodage de nos fichier en <em>ISO-8859-1</em>. <br/>Pour cela, nous utilisons la commande <b>iconv -f UTF-8 -t iso-8859-1 3236.txt > fichier.txt</b>.

<br/>
<br/>

<%= image_tag "patron.jpg" %>


<p><br/> La commande est donc : <b>perl BAO3.pl fichier_cordial fichier_txt_patrons</b>.</p>




<label>

<%= partial "partials/code", :locals => { :code_file => "assets/margaux/BAO3_1_margaux.pl"} %>
<% code("perl") do %>
#!/usr/bin/perl
# Extraction des patrons morphosyntaxiques dans les étiquetages produits avec Cordial
# Données : fichier d'entrée passé dans le logiciel cordial.
#  commande : perl BAO3 new_3208.cnr


use utf8;
binmode STDOUT, ":utf8";

#---------LECTURE DU FICHIER -------------------------------

open (FICHIER, "<:encoding(utf8)", $ARGV[0]);
my $chaine="";

# Boucle principale
while (my $ligne=<FICHIER>)
{

    $ligne=~s/\r//g;
    chomp $ligne;

#---------Récupération du POS et du TOKEN -------------------------------

    if (($ligne=~/^([^\t]+)\t[^\t]+\t([^\t]+)$/) and ($ligne!~/PONCT_FORT/))
    {


        my $f=$1;
        my $c=$2;
        $f=~s/ /%/g;


        $chaine = $chaine . $c ."_".$f." ";
    }

    else
    {
        open (TERM, "<:encoding(utf8)", $ARGV[1]);
        while ($terme=<TERM>)
        {
            chomp($terme);
            $terme=~s/([^ ]+)/$1_\[\^ \]+/g;

        while ($chaine=~/($terme)/g)
        {

            my $correspondance=$1;
            $correspondance=~s/[A-Z]+_//g;
            $correspondance=~s/%/ /g;
            print $correspondance,"\n";

        }


        }
        close(TERM);
        $chaine="";
    }

}

close FICHIER;
"



<% end %>
</label>

<h4> 2e solution :</h4>

<p> La deuxième solution était un exercice effectué dans une autre matière qui se nomme <em>Document Structuré</em>.
<br/> Cette solution est effectuée avec le langage XML et des recommandations XSLT et XPATH.</p>

<p> Nous avons trois feuilles de style xslt :</p>
<p> La première permet d'extraire le patron morphosyntaxique <b>NOM ADJ</b></p>

<label>
<%= partial "partials/code", :locals => { :code_file => "assets/margaux/exo12/exo12-Q2-1_margaux.xsl"} %>

<% code("xml") do %>
<?xml version="1.0" encoding="iso-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="utf-8"/>

<xsl:template match="/">
    <html>
        <body  bgcolor="#81808E">
            <table align="center" width="50%"  bgcolor="white" bordercolor="#3300FF" border="1">
                <tr bgcolor="black">
                    <td width="90%" valign="top"><font color="white"><h1>Extraction de patron <font color="red"><b>NOM</b></font><xsl:text> </xsl:text><font color="blue"><b>ADJ</b></font></h1></font></td>
                </tr>
                <tr><td>
                    <blockquote><xsl:apply-templates select="./parcours/item/title/article"/></blockquote></td></tr>
            </table>
        </body>
    </html>
<xsl:apply-templates select="//element"/>
</xsl:template>

<xsl:template match="element">
<xsl:choose>
<xsl:when test="(./data[contains(text(),'NOM')]) and (following-sibling::element[1][./data[contains(text(),'ADJ')]])">
    <font color="red"><xsl:value-of select="./data[3]"/></font><xsl:text> </xsl:text>
</xsl:when>
<xsl:when test="(./data[contains(text(),'ADJ')]) and (preceding-sibling::element[1][./data[contains(text(),'NOM')]])">
    <font color="blue"><xsl:value-of select="./data[3]"/></font>
    <br/>
</xsl:when>
</xsl:choose>
</xsl:template>

</xsl:stylesheet>

<% end %>
</label>

<h4><a href="assets/exo12/exo12-Q2-1_margaux.html"> Résultat </a></h4>

<br/>
<p> La deuxième permet d'extraire le patron morphosyntaxique <b>NUM NOM VER PUN</b></p>

  <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/margaux/exo12/exo12-Q2-2_margaux.xsl"} %>
  <% code("xml") do %>
  <?xml version="1.0" encoding="utf-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
      <xsl:output method="html" encoding="utf-8"/>
      <xsl:template match="/">
          <html>
              <body  bgcolor="#81808E">
                  <table align="center" width="50%"  bgcolor="white" bordercolor="#3300FF" border="1">
                      <tr bgcolor="black">
                          <td width="90%" valign="top"><font color="white"><h1>Extraction de patron <font color="red"><b>NUM</b></font><xsl:text> </xsl:text><font color="blue"><b>NOM</b></font><xsl:text> </xsl:text><font color="green"><b>VER</b></font><xsl:text> </xsl:text><font color="white"><b>PUN</b></font></h1></font></td>
                      </tr>
                      <tr><td>
                          <blockquote><xsl:apply-templates select="./parcours/item/title/article"/></blockquote></td></tr>
                  </table>
              </body>
          </html>
          <xsl:apply-templates select=".//article"/>
      </xsl:template>


      <xsl:template match="article">
          <xsl:for-each select="element">
              <xsl:if test="(./data[1][contains(text(),'NUM')])">
                  <xsl:variable name="p1" select="./data[3]/text()"/>
                  <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'NOM')]]">
                  <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                  <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'VER')]]">
                  <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                  <xsl:if test="following-sibling::element[3][./data[1][contains(text(), 'PUN')]]">
                  <xsl:variable name="p4" select="following-sibling::element[3]/data[3]/text()"/>
                    <font color="red"><xsl:value-of select="$p1"/></font>
                    <xsl:text> </xsl:text>
                    <font color="blue"><xsl:value-of select="$p2"/></font>
                    <xsl:text> </xsl:text>
                    <font color="green"><xsl:value-of select="$p3"/></font>
                    <xsl:text> </xsl:text>
                    <font color="white"><xsl:value-of select="$p4"/></font>
                      <br/>

                      </xsl:if>
                  </xsl:if>
              </xsl:if>
            </xsl:if>
          </xsl:for-each>

      </xsl:template>

  </xsl:stylesheet>


  <% end %>
  </label>

<h4><a href="assets/exo12/exo12-Q2-2_margaux.html"> Résultat </a></h4>

<br/>
<p> La troisième permet d'extraire le patron morphosyntaxique <b>NOM VER ADJ</b></p>

<label>
<%= partial "partials/code", :locals => { :code_file => "assets/exo12/exo12-Q2-3_margaux.xsl"} %>
<% code("xml") do %>
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="html" encoding="utf-8"/>
    <xsl:template match="/">
        <html>
            <body  bgcolor="#81808E">
                <table align="center" width="50%"  bgcolor="white" bordercolor="#3300FF" border="1">
                    <tr bgcolor="black">
                        <td width="90%" valign="top"><font color="white"><h1>Extraction de patron <font color="red"><b>NOM</b></font><xsl:text> </xsl:text><font color="blue"><b>VER</b></font><xsl:text> </xsl:text><font color="green"><b>ADJ</b></font></h1></font></td>
                    </tr>
                    <tr><td>
                        <blockquote><xsl:apply-templates select="./parcours/item/title/article"/></blockquote></td></tr>
                </table>
            </body>
        </html>
        <xsl:apply-templates select=".//article"/>
    </xsl:template>


    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(),'NOM')])">
                <xsl:variable name="p1" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'VER')]]">
                    <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'ADJ')]]">
                        <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                         <font color="red"><xsl:value-of select="$p1"/></font>
                            <xsl:text> </xsl:text>
                            <font color="blue"><xsl:value-of select="$p2"/></font>
                            <xsl:text> </xsl:text>
                            <font color="green"><xsl:value-of select="$p3"/></font>

                            <br/>

                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>

    </xsl:template>

</xsl:stylesheet>


  <% end %>
  </label>

<h4><a href="assets/exo12/exo12-Q2-3_margaux.html"> Résultat </a></h4>

<h4> 3e solution :</h4>
<p> Cette troisième solution propose des recommandations <b>XQUERY</b> pour extraire les patrons morphosyntaxiques "NOM ADJ" et "NOM PRP NOM".</p>
<
<p> Ci-dessous la recommandation pour le patron morphosyntaxique "NOM ADJ"</p>
<label>

  <%= partial "partials/code", :locals => { :code_file => "assets/margaux/exo12/exo12-Q7_margaux.xq"} %>

  <% code("xml") do %>
for $rss in doc("3244")//article
for $element in $rss/element
let $next := $element/following-sibling::element[1]
where $element/data[1] = "NOM" and $next/data[1] = "ADJ"
return <PATRON-NOM-ADJ>{$element,$next}</PATRON-NOM-ADJ>

  <% end %>
  </label>

<h4><a href="assets/exo12/exo12-Q7_margaux.txt"> Résultat </a></h4>

<p> Ci-dessous la recommandation pour le patron morphosyntaxique "NOM PRP NOM"</p>
<label>

  <%= partial "partials/code", :locals => { :code_file => "assets/margaux/exo12/exo12-Q8_margaux.xq"} %>

  <% code("xml") do %>
for $rss in doc("3244")//article
for $element in $rss/element
let $next := $element/following-sibling::element[1]
let $nextN := $next/following-sibling::element[1]
where $element/data[1]="NOM" and $next/data[1]="PRP" and $nextN//data[1]="NOM"
return <PATRON-NOM-PRP-NOM>{$element,$next,$nextN}</PATRON-NOM-PRP-NOM>

  <% end %>
  </label>

<h4><a href="assets/exo12/exo12-Q8_margaux.txt"> Résultat </a></h4>

<h3>DIFFICULTÉ : se faire voler son ordinateur</h3>
  <p> Je me retrouve à cette étape du projet sans ordinateur et avec toutes mes données perdues ainsi que mes programmes.
  <br/> Mes rubriques seront donc plus les mêmes car sans ordinateur, mes collègues ont fait fonctionner leurs programmes sur les rubriques qu'elles pouvaient.
  <br/> La deuxième partie de la Boîte à outils n°3 ainsi que les Boîte à outils n°4 ne s'effectueront pas avec les mêmes rubriques.
  </p>
  <p> Les nouvelles rubriques que j'utiliseraient seront :
  <br/> - La rubrique 823353 qui est la rubrique <b> Politique</b>
  <br/> - La rubrique 3208 qui est la rubrique <b> À la Une </b>
  <br/> - La rubrique 3246 qui est la rubrique <b> Culture</b></p>

<h3> Suite BAO3 </h3>

<p> Le deuxième solution perl pour extraire des patrons morphosyntaxiques utilise les données extrait avec <em> TreeTagger</em>.
<br/>La grande différence que ce script possède par rapport qu premier que l'on a pu observer plus haut
est que les données entrantes sont placées dans un tableau, sont ensuite analysées par notre programme puis extraite du tableau.
<br/> Nous possédons alors deux scripts pour cette solution : un pour chaques patrons.</p>

<h4><b> PATRON NOM ADJECTIF </b></h4>

<label>

<%= partial "partials/code", :locals => { :code_file => "assets/margaux/BAO3-2-NOM_ADJ.pl"} %>

<% code("perl") do %>

open(FILE,"$ARGV[0]");

# Définition du tableau #
my @lignes=<FILE>;
close(FILE);

#Début de la boucle #
while (my $ligne=shift(@lignes)) {

    chomp $ligne;
    my $sequence="";
    my $longueur=0;

    # Recherche des NOMS #
    if ( $ligne =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
		my $forme=$1;
		$sequence.=$forme;
		$longueur=1;
		my $nextligne=$lignes[1];

    # Recherche des ADJECTIFS #
  		if ( $nextligne =~ /<element><data type=\"type\">ADJ<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
  			my $forme=$1;
  			$sequence.=" ".$forme;
  			$longueur=2;
  		}
    }
    if ($longueur == 2) {
	    print $sequence,"\n";
    }
}

<% end %>
</label>

<h4> Résultats </h4>
<h4><a href="assets/margaux/result_perl_treetagger/a-la-une-nomadj.txt"> Rubrique À la Une </a></h4>
<h4><a href="assets/margaux/result_perl_treetagger/pol-nomadj.txt"> Rubrique Politique </a></h4>
<h4><a href="assets/margaux/result_perl_treetagger/culture-nomadj.txt"> Rubrique Culture </a></h4>

h4><b> PATRON NOM PRÉPOSITION NOM </b></h4>

<label>

<%= partial "partials/code", :locals => { :code_file => "assets/margaux/BAO2-2-NOM_PREP_NOM.pl"} %>

<% code("perl") do %>

open(FILE,"$ARGV[0]");

my @lignes=<FILE>;
close(FILE);
while (my $ligne=shift(@lignes)) {
    chomp $ligne;
    my $sequence="";
    my $longueur=0;

# RECHERCHE DU NOM #
    if ( $ligne =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
		my $forme=$1;
		$sequence.=$forme;
		$longueur=1;

# RECHERCHE DU PRP #
		my $nextligne=$lignes[1];
  		if ( $nextligne =~ /<element><data type=\"type\">PRP<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
  			my $forme=$1;
  			$sequence.=" ".$forme;
  			$longueur=2;


# RECHERCHE DU NOM #
  			my $nextligne1=$lignes[3];
  			if ( $nextligne1 =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
  				my $forme=$1;
  				$sequence.=" ".$forme;
  				$longueur=3;
  			}
  		}
    }
    if ($longueur == 3) {


    print $sequence,"\n";

    }
}

<% end %>
</label>

<h4> Résultats </h4>
<h4><a href="assets/margaux/result_perl_treetagger/a-la-une-npn.txt"> Rubrique À la Une </a></h4>
<h4><a href="assets/margaux/result_perl_treetagger/pol-npn.txt"> Rubrique Politique </a></h4>
<h4><a href="assets/margaux/result_perl_treetagger/culture-npn.txt"> Rubrique Culture </a></h4>
