---
site:
  title: Projet BAO
  categorie: Ferial Yahiaoui
  description: Projet de traitement automatique des langues, utilisant Perl et XSLT

author:
  all: Milena Chaîne, Margaux Duhayon, Ferial Yahiaoui
  milena: Milena Chaîne
  margaux: Margaux Duhayon
  ferial: Ferial Yahiaoui
  school: Inalco

master:
  site: "http://www.tal.univ-paris3.fr/plurital/"


layout: ferial

---

<% content_for :logo do %>
<%= image_tag "vintage-mechanics-tool-box.jpg" %>
<% end %>


<p>Bienvenue sur ma page.</p>
<p>J'ai pour ma part travaillé sur les rubriques suivantes:<br/>
<br/> - La rubrique 3476 qui est la rubrique <em>Cinéma</em>.
<br/> - La rubrique 3232 qui est la rubrique <em>Idées</em>.
<br/> - la rubrique 3260  qui est la rubrique <em>Livres</em>.</p>

<p>Le choix des rubriques s'est fait en fonction des thèmes pouvant être liés les uns aux autres. Etant donné qu'il est question de l'actualité de l'année 2017 concernant le cinéma et les livres, mais aussi au sujet des interviews et des tribunes (rubrique Idées) ayant été rapportées par le journal Le Monde tout au long de l'année ; et par souci de pertinence dans le choix des motifs à la dernière étape du projet, un parallèle sera fait entre les résultats obtenus et nos recherches concernant tout ce qui a pu marqué l'actualité au courant de cette année autour de ces thèmes.</p>

<p>Cette page contient les différentes Boîtes à Outils, leurs explications, les résultats obtenus, ainsi que les analyses qui en découlent.</p>
<p>Tous les scripts sont visibles sur la page elle-même et téléchargeables. Pour naviguer entre les différentes boîtes à outils, vous pouvez utiliser la barre d'onglets ci-dessous.</p>

<p>Bonne visite !</p>



<%= partial "partials/h3", :locals => { :raccourci => "bao1_2", :titre => "Boîtes à outils 1 et 2 : Parcours, filtrage, création et étiquetage des fichiers créés"} %>
<%= partial "partials/onglets_bao_ferial" %>




	<%= image_tag 'schema/bao_schema_1_2.png' %>

	<p>La deuxième BAO utilise les résultats de la première. En effet, la BAO1 s’occupe d’extraire le texte de chaque rubrique en récupérant le titre et la description de celles-ci, sous deux formats : un texte brut + un fichier XML. Tout cela en parcourant l’arborescence du fils RSS jusqu’au traitement de toutes les rubriques. Ensuite, la BAO2 récupère les fichiers XML pour les étiqueter morphosyntaxiquement grâce à l’annotateur « TreeTagger ».
<br/>
Que faire de nos fichiers au format TXT?<br/>
Après les avoir converti en ISO 8859-15, on les passe à l’annotateur « Cordial » qui les étiquètera morphosyntaxiquement.<br/>
Ce sont ces fichiers étiquetés par deux annotateur différents qui seront utilisés par la BAO3.<br/>
Ci-dessous, le programme en question:

</p>


<label>

<%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO2_extrac_etiq_utf.pl"} %>
 <% code("perl") do %>

#!/usr/bin/perl

<<DOC;
usage : perl BAO2_extrac_etiq.pl Library numéro de la rubrique
Par exemple : perl BAO2_extrac_etiq.pl Library 3208
Le programme prend en entrée le nom du répertoire contenant les fichiers à traiter et le numéro de la rubrique à traiter
DOC

 #-----------------------------------------------------------

 # recupère le nom du répertoire racine

 my $rep="$ARGV[0]";

 # recupère le nom de la rubrique

 my $rubrique = "$ARGV[1]";

 # initialise

 my %dico=();

 $rep=~ s/[\/]$//; # assure que le nom du répertoire ne se termine pas par un "/"

 $encodage = "utf-8";

 # initialisele  compteur de fichichiers à 1

 my $compteurfile=1;

 # initialisation du compteur d items à 0

 my $compteuritem=0;

 # initialise les fichiers d output

 my $output1=$rubrique.".xml"; # initialisation du fichier d output XML
 my $output2=$rubrique.".txt"; # initialisation du fichier d output TXT

 # ouvre les fichiers d output

 if(!open (FILEOUT, ">:encoding($encodage)", $output1)) { die "Pb à l'ouverture du fichier $output1" };
 if(!open (FILEOUT2, ">:encoding($encodage)", $output2)) { die "Pb à l'ouverture du fichier $output2" };

 # écris l entête du fichier d output XML

 print FILEOUT "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n";
 print FILEOUT "<PARCOURS>\n";
 print FILEOUT "<NOM>Ferial Yahiaoui</NOM>\n";
 print FILEOUT "<FILTRAGE>\n";


# lance la récursion...elle se terminera après examen de toute l arborescence

 #----------------------------------------
 &parcoursarborescencefichiers($rep);
 #----------------------------------------

# réouvre le fichier d output XML et écris les balises fermantes

 if(!open (FILEOUT, ">>:encoding($encodage)", $output1)) { die "Pb à l'ouverture du fichier $output1" };

 print FILEOUT "\n</FILTRAGE>\n";
 print FILEOUT "</PARCOURS>\n";

# ferme le fichier XML

 close(FILEOUT);


 exit;
 #----------------------------------------------

 # définis le sous-programme responsable de parcourir le répertoire

 sub parcoursarborescencefichiers {

	 # récupère le répertoire

     my $path = shift(@_);

	 # ouvre le répertorie reçu en argument, donc $path

     opendir(DIR, $path) or die "can't open $path: $!\n";

	 # lis le repertoire, readdir renvoit une liste, celle des fichiers à l intérieur de DIR, on les met dans un listes # ne traite pas./, courant../ précédent sinon, on se retrouve dans une boucle

     my @files = readdir(DIR);
     closedir(DIR);
     foreach my $file (@files) { # la liste obtenue est relative au répertoire ouvert
     next if $file =~ /^\.\.?$/; # next: passe au prochain élément si l actuel ne correspond pas à celui chérché
     $file = $path."/".$file;

	# vrai si l objet est un répertoire

     if (-d $file) {
       print "<NOUVEAU REPERTOIRE> ==> ",$file,"\n";

		   # récurse!

       &parcoursarborescencefichiers($file);
       print "<FIN REPERTOIRE> ==> ",$file,"\n";
     }

	 # vrai si l objet est un fichier

     if (-f $file) {

		 # si le fichier en question correspond à ce pattern

       if($file =~/$rubrique.+\.xml$/)
       {
         print "<",$compteurfile++,"> ==> ",$file,"\n";

		 #  alors, ouvre le fichier de la rubrique pour

         open (FIC, "<encoding($encodage)", $file);

		 # intialise varaibale texte à une chaîne vide

         my $texte="";

		 # tant que la variable ligne prend comme valeur l ensemble du texte

         while (my $ligne = <FIC>){

		   # supprime les retours à la ligne

           chomp $ligne;

		   # nettoie la ligne du retour chariot

           $ligne =~ s/\r//g;

		   # concatène l ensemble du texte

           $texte = $texte . $ligne;

       }

       close FIC;


       # nettoie le texte

       $texte =~ s/>\s+</></g;

	   # tant que le texte recherché correspond à ce match

       while($texte=~
       m/<item>.*?<title>([^<]*?)<\/title>.*?<description>([^<]*?)<\/description>/g)
       {

		# stocke les titres dans la variable $titre
         my $titre = $1;

		 # stocke les descriptions dans la variable $description

         my $description = $2;


         ($titre, $description) = &nettoyage($titre, $description); # appel du sous-programme nettoyage
         if(!(exists $dico {$titre})) # ne prends pas en compte les titres redondants
         {
           $dico{$titre} = 1;

           print FILEOUT2 "$titre.\n$description\n\n";


           $compteurItem++;

		   # initialisation des variables contenant les titres + descriptions étiquetés

           my ($titre_etiq, $description_etiq) = &etiquetage($titre, $description);

		   # écris dans l'output XML le contenu étiqueté

           print FILEOUT "<item number=\"$compteurItem\">\n<titre>$titre_etiq</titre>\n<description>$description_etiq</description>\n</item>\n";

         }

       }

       }



     }
 }

 # définition du sous-programme nettoyage

 sub nettoyage {

   # @_ c'est une liste
   # my $var1 = $_[0];

   my $var1 = shift(@_);   # shift supprime le premier élément et le recupère dans une variable
   my $var2 = shift(@_);

   # $var1 et $var2 prennennet respectivement les valeurs des titres et descriptions

   # nettoie les titres + descriptions des entités HTML

     $var1 =~s/&lt;.+?&gt;//g;
     $var2 =~s/&lt;.+?&gt;//g;
     $var1 =~s/&amp;/et/g;
     $var2 =~s/&amp;/et/g;
     $var1=~s/\?\.$/\?/;

   return $var1,$var2;

 }
 #----------------------------------------------

 # définition du sous-programme étiquetage

 sub etiquetage {

   my $var1 = shift(@_); # l'input est le titre et la description
   my $var2 = shift(@_);

   #-------------------titre

   open(OUT, ">:encoding(utf8)", "titre_tmp.txt");
   print OUT $var1;

   close OUT;

  # system permet de lancer une commande de notre système d exploitation, ici une commande bash
  # la première permettant de segmenter les titres en tokens et de les passer à l annotateur TreeTagger

   system("perl tokenise-utf8.pl titre_tmp.txt | ./tree-tagger/bin/tree-tagger -lemma -token -no-unknown ./tree-tagger/lib/french-utf8.par > titre_tmp_etiq.txt"); # resultat envoyé dans des fichiers temporaires permattant de stocker chaque titre traité

   # la seconde commande permet de trasnformer le résultat de l'étiquetage en fichier XML

   system("perl treetagger2xml-utf8.pl titre_tmp_etiq.txt utf8");

   # le mode slurp permet de lire, localement, le texte d une traite

   local $/=undef;

   open (FIC, "<:encoding(utf8)", "titre_tmp_etiq.txt.xml");
   my $titre_retour=<FIC>;
   $titre_retour=~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;

   #------------------------------------------description

   open(OUT, ">:encoding(utf8)", "description_tmp.txt");
   print OUT $var2;


   close OUT;

   system("perl tokenise-utf8.pl description_tmp.txt | ./tree-tagger/bin/tree-tagger -lemma -token -no-unknown ./tree-tagger/lib/french-utf8.par
    > description_tmp_etiq.txt"); # resultat envoyé dans des fichiers temporaires permattnt de stocker chaque description traitée

   system("perl treetagger2xml-utf8.pl description_tmp_etiq.txt utf8");
   $/=undef;
   open (FIC, "<:encoding(utf8)", "description_tmp_etiq.txt.xml");
   my $description_retour=<FIC>;
   $description_retour=~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;

   return $titre_retour, $description_retour;



 }



 }

  <% end %>
</label>

 <p><div class="explication"><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Ce programme se compose de quatre blocs: dont 3 sous-programmes où certais sont imbriqués les unes dans les autres.<br/><br/>


bloc1: <br/>

	 Le lancement du du programme requiert deux arguments qui sont le nom du répertoire contenant l’ensemble du fils RSS ainsi que le numéro de la rubrique choisie dont le texte doit être extrait. Il va ensuite initialiser les différents fichiers de sortie, de parcourir l’arborescence, donc le répertoire du fils RSS et d’en extraire le contenu ciblé.<br/><br/>


bloc2:<br/>

	La fonction récursive parcoursarboresence est définie et prend, s’il correspond à un répertoire, le premier élément, en l’occurrence le répertoire « Library » contenant les fichiers des rubriques.
Elle fait elle-même appel au sous-programme etiquetage pour initialiser les variables contenant les titres et descriptions « nettoyés » par un autre sous-programme, nettoyage. <br/><br/>

bloc3: <br/>

	La fonction nettoyage est définie par la suppression des balises HTML et par le remplacement des entités HTML par leurs correspondants textuels.<br/>

bloc4: <br/>

	pour chaque token (mot) nous obtenons sa catégorie morphosyntaxique et son lemme. La fonction étiquetage est définie par l’appel des programmes Perl responsables de la segmentation du texte, de son annotation, ainsi que de sa transformation en fichier XML. Ce dernier sera formé de balises indiquant pour chaque token sa catégorie morpho-syntaxique et son lemme.<br/>

Il est à noter que seul le fichier d’output XML est étiqueté morphosyntaxiquement par TreeTagger dans ce programme. Le fichier d’output TXT sera, quant à lui, étiqueté séparément par Cordial.<br/>

Les deux, seront par la suite utilisés par la BAO3 pour en extraire, à partir de patrons morpho-syntaxiques prédéfinis, les éléments lexicalisés qui y sont associés.
</p></div>

  <p><div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %> Les résultats obtenus par l'étiquetage des fichiers XML, <b><a href="assets/ferial/rubriques_etiquetees_tagger.zip" download>sont téléchargeables ici</a></b><br/> et ceux obtenus par l'étiquetage des fichiers TXT par Cordial<b><a href="assets/ferial/rebriques_etiquetees_cordial" download> sont téléchargeables ici</a></b> .</p></div>
<center><p>Les fichiers XML étiquetés par TreeTagger se présentent ainsi :</p></center>
<center><%= image_tag 'ferial/3232_tagger.png' %></center>
<center><p>Les fichier TXT étiquetés par Cordial se présentent ainsi :</p></center>
<center><%= image_tag 'ferial/3232_cordial.png' %></center>





 <%= partial "partials/h3", :locals => { :raccourci => "bao3", :titre => "Boîte à outils 3 : Extraction des patrons morphosyntaxiques"} %>
 <%= partial "partials/onglets_bao_ferial" %>



  	<%= image_tag 'schema/bao_schema_3.png' %>

  	<p>L’objectif de la BAO3 est d’extraire, selon des patrons morphosyntaxiques donnés, les éléments lexicalisés correspondants et ce, grâce à plusieurs solutions proposées, en fonction des fichiers annotés à exploiter (fichiers TXT et XML étiquetés).



  </p>




 <h4><B>1) Solutions Perl permettant l'extraction de patrons morphosyntaxiques à partir des fichiers TXT étiquetés par "Cordial" </B></h4>

<div class="explication"><p>	Les données des fichiers taggés par Cordial se structurent en 3 colonnes:<br/><br/>
					<ul>

					<li>1. le token</li><br/>
					<li>2. son lemme</li><br/>
					<li>3. sa catégorie morphosyntaxique</li><br/><br/>

				</ul>

Par exemple: rentabilité	rentabilité	NCFS<br/>

<br/>Les deux programmes prennent plusieurs arguments: le fichier taggé et la liste des éléments constitutifs du patron (exprimé chacun par exemple sur la forme d'une regexp).<br/>

Les programmes doivent retrouner des éléments lexicalisés correpsondant aux patrons indiqués.
</p></div><br/><br/>





 <%= image_tag 'cog_transparent_32px.png', :class => "icon" %><B>1.1) Premier programme Perl</B>


 <div class="explication"><p> Cette solution permet de comparer des chaînes de caractères avec une suite de POS grâce à une expression régulière. L'inconvénient qu'elle présente c'est qu'il faut à chaque fois changer l'argument du fichier de patron recherché visé.

 </p></div><br/><br/>


 <label>

<%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO3_patrons_utf"} %>
 <% code("perl") do %>

  #!/usr/bin/perl

 <<DOC;
 usage : perl BAO3_patrons.pl rubrique_utf.cnr patrons.txt
 Par exemple : perl BAO3_patrons.pl 3208_utf.cnr patrons.txt
 Le programme prend en entree la sortie Cordial la rubrique etiquetee et des patrons morphosyntaxiques a extraire correspondant a l expression reguliere (exemple : NC.. PREP NC..)
 DOC


 #----------------------------------------
 use utf8;
 binmode STDOUT, ":utf8";
 my $chaine="";
 open (FIC, "<:encoding(utf8)", $ARGV[0]);

 while (my $ligne=<FIC>) {

 	chomp $ligne;
 	$ligne=~s/\r//g;

 	#print $ligne;

 	if (($ligne=~/^(.+?)\t.+?\t(.+?)$/) and ($ligne !~/PCTFORTE/)) {

 		my $f=$1;

 		my $c=$2;

		$f=~s/ /#/g;




 	$chaine = $chaine . $c."_".$f." ";
 	#$chaine = $chaine . $c."_".$f." ";
 	#print $chaine;

 	# print $chaine;
 	# $continu=<STDIN>;


 	}
 	else {
 		#print $chaine;
 		#$continu=<STDIN>;
 		open(TERM,$ARGV[1]);
 		while (my $terme=<TERM>){

 			chomp($terme);
 			$terme=~s/([^ ]+)/$1_\[\^ \]+/g;


 			while ($chaine=~/$terme/g){

 				my $correspondance=$&;
 				$correspondance=~s/[A-Z]+_//g;
 				$correspondance=~s/#/ /g;
 				print $correspondance, "\n";
 			}

 		}
 		close(TERM);
 		$chaine="";
 	}


 	}

 close (FIC);

  <% end %>
   </label>


<br/><br/>  <%= image_tag 'cog_transparent_32px.png', :class => "icon" %><B>1.2) Deuxième programme Perl (programme N-grammes)</B>

  <div class="explication"><p>	Pour cette solution, j'ai opté pour celle proposée par Axel Court. En effet, des tables de hachage sont utilisées dans ce script qui consiste à chercher chaque patron devenant la clé d'un %hash. Au fur et à mesure qu'un patron est reconnu, il est ajouté à la liste des valeurs de cette clé. Chaque clé stockée dans une table de hachage est un objet unique, et sa valeur peut être représentée par une chaîne de caractères ($string) ou une liste (@liste). Dans notre cas, des @tableaux sont stockés dans une %hash. Cette option est avantageuse dans le sens où il est plus rapide de vérifier si les éléments constitutifs d'un patron de POS du fichier TXT étiqueté est une clé dans le tableau associatif, que de comparer deux strings. Elle présente cependant le désavantage d'exiger la précision dans la défintion des patrons recherchés, car Cordial est précis dans son annotation contrairement à TreeTagger, qui lui, ne va pas dans le détail pour indiquer le genre et le nombre, par exemple, d'un adjectif ou d'un nom.

  </p></div><br/><br/>



  <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/ferial/extraction-hach-ngram-cordial_utf.pl"} %>

 <% code("perl") do %>

 #!/usr/bin/perl

#----------------------------------
# Ouverture des fichiers en lecture
#----------------------------------
open (FICTAG, $ARGV[0]) or die ("probleme sur ouverture de la sortie CORDIAL...");
open (FICPOS, $ARGV[1]) or die ("probleme sur ouverture du fichier des patrons...");
#----------------------------------------------------
# On stocke les patrons dans une table de hachage
#----------------------------------------------------
my %listedespatrons;
my @liste = ();
print "Lecture du fichier de POS\n";
while (my $lignepos = <FICPOS>) {
    chomp($lignepos);
    my @patron = split(/\#/, $lignepos);
  #------------------------------------------------------------------------------------------
  # @liste gardera en mémoire le nombre de POS dont est composé chaque patron syntaxique
    push(@liste, $#patron+1);
  #------------------------------------------------------------------------------------------
  $lignepos =~ s/#/ /g;
  #-----------------------------------------------------------------------------------------------------------------
  # Attention, on stocke des tableaux comme valeurs, donc initialiser ces valeurs à () et non "" !
  # Sinon le script stockera la totalité des suites reconnues (soit plus de 10 000) comme valeur de chaque clé !
    $listedespatrons{$lignepos} = ();
  #-----------------------------------------------------------------------------------------------------------------


}
#------------------------------------------------------------------------------------------------------------------------
# Suppression des doublons de @patron : on obtient des valeurs uniques qui serviront à générer des n-grammes de POS
my %listengramstemp  = map { $_, 1 } @liste;
my @listedesngrams = keys %listengramstemp;


#------------------------------------------------------------------------------------------------------------------------
close(FICPOS);
#---------------------------
# Initialisation des listes
#--------------------------
my @malignesegmentee = ();
my @listedetokens = ();
my @listedelemmes = ();
my @listedepos = ();
#-------------------------------------------
# Lecture du fichier de tags ligne par ligne
#-------------------------------------------
print "Lecture du fichier a analyser\n";
while (my $ligne = <FICTAG>) {
    #-------------------------------------------------------------------------------------
    # On ne s'occupe pas des lignes qui ne respectent pas la modèle mot tab mot tab mot
    #-------------------------------------------------------------------------------------

    if (($ligne=~/^[^\t]+\t[^\t]+\t[^\t]+$/) and ($ligne !~/PCTFORTE/)){

  #-------------------------------------------
  # Suppression du caractère de saut de ligne
  chomp($ligne);
  #-------------------------------------------
  # Remplissage des listes
  @malignesegmentee = split(/\t/, $ligne);
  push(@listedetokens, $malignesegmentee[0]);
  push(@listedelemmes, $malignesegmentee[1]);
  push(@listedepos, $malignesegmentee[2]);
  #-------------------------------------------

    }

}
close(FICTAG);
#--------------------------------------------------------------------------------------
# Génération de n-grammes de POS (en fonction du nombre de POS dans les patrons)
# et recherche si chaque n-gramme généré correspond à un patron de %listedespatrons
#--------------------------------------------------------------------------------------
print "Recherche des patrons syntaxiques\n";
foreach my $n (@listedesngrams) {
  $n = $n-1;
  my $j = 0;
  until ($j+$n > $#listedepos) {
    my $ngram = join(" ", @listedepos[$j .. $j+$n]);

    #-----------------------------------------------------------------
    # Si la suite de POS est reconnue comme clé de %listedespatrons
    # on stocke les tokens correspondants en valeur du hash
    if (exists $listedespatrons{$ngram}) {
      my $motsreconnus = join(" ", @listedetokens[$j .. $j+$n]);
      push(@{$listedespatrons{$ngram}},$motsreconnus);
    #-----------------------------------------------------------------



    }
    $j++;
  }
}
#-------------------------------------------------
# Impression des résultats de l'extraction
#-------------------------------------------------
my $dump = "";
#-------------------------------------------------
# Parcours de la table de hachage
print "Ecriture des resultats\n";
while ( ($key, $value) = each(%listedespatrons) ) {
    $dump .= "------------------------\n";
    $dump .= "$key\n-------------------------\n";


  #--------------------------------------------------------------
  # Parcours du tableau contenant les suites de mots reconnues
  # qui correspondent au patron syntaxique (la clé)
    foreach my $term (@$value) {
    $dump .= $term;
    $dump .= "\n";


  #--------------------------------------------------------------
  }
  $dump .= "\n\n\n";

}
#-------------------------------------------------

open(OUT, ">:encoding(utf8)", "resultat.txt");

print OUT $dump;
close(OUT);
exit;

 <% end %>
</label>




   <h4><B>2) Solutions Perl + XSLT + XQuery permettant l'extraction de patrons morphosyntaxiques à partir des fichiers XML étiquetés par "TreeTagger" </B></h4>

    <div class="explication"><p>	Les données des fichiers taggés par TreeTagger se structurent en 3 colonnes:<br/><br/>
    					<ul>

    					<li>1. la catégorie morphosyntaxique du token</li><br/>
    					<li>2. son lemme</li><br/>
    					<li>3. le token </li><br/><br/>

    				</ul>

    Par exemple: <label>

 <% code("xml") do %><element><data type="type">NOM</data><data type="lemma">l’économiste</data><data type="string">l’économiste</data></element>
 <%end%></label>

 <br/>


    </p></div><br/><br/>



     <%= image_tag 'cog_transparent_32px.png', :class => "icon" %><B>2.1) Programme Perl</B><br/><br/>


     <br/>Les deux programmes prennent comme argument: le fichier XML taggé par TreeTagger.<br/>

     Les programmes doivent retrouner des éléments lexicalisés correpsondant à la structure des fichiers des rubriques taggées.<br/><br/>

   <P>2.1.1) Pour le patron NOM_ADJ</P>

   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO3_solu_treetagger_NOM_ADJ_utf.pl"} %>

 <% code("perl") do %>

#!/usr/bin/perl

open(FILE,"$ARGV[0]");
#--------------------------------------------
# le patron cherché ici est du type "NOM_ADJ"
#--------------------------------------------
my @lignes=<FILE>;
close(FILE);
while (my $ligne=shift(@lignes)) {
    chomp $ligne;
    my $sequence="";
    my $longueur=0;
    if ( $ligne =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
    my $forme=$1;
    $sequence.=$forme;
    $longueur=1;
    my $nextligne=$lignes[1]; # saut de ligne dans nos fichiers XML
      if ( $nextligne =~ /<element><data type=\"type\">ADJ<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
        my $forme=$1;
        $sequence.=" ".$forme;
        $longueur=2;
      }
    }
    if ($longueur == 2) {
      print $sequence,"\n";
    }
}


 <% end %>
</label>
<br/><br/>



    <P>2.1.2) Pour le patron NOM_PRP_NOM</P>

    <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO3_solu_treetagger_NOM_PREP_NOM_utf.pl"} %>

 <% code("perl") do %>

#!/usr/bin/perl

open(FILE,"$ARGV[0]");
#--------------------------------------------
# le patron cherché ici est du type "NOM_PRP_NOM";

#--------------------------------------------
my @lignes=<FILE>;
close(FILE);
while (my $ligne=shift(@lignes)) {
    chomp $ligne;
    my $sequence="";
    my $longueur=0;

    if ( $ligne =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
    my $forme=$1;
    $sequence.=$forme;
    $longueur=1;

    my $nextligne=$lignes[1]; # saut de ligne dans nos fichiers XML
      if ( $nextligne =~ /<element><data type=\"type\">PRP<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
        my $forme=$1;
        $sequence.=" ".$forme;
        $longueur=2;

        my $nextligne1=$lignes[3]; # saut de ligne dans nos fichiers XML
        if ( $nextligne1 =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
          my $forme=$1;
          $sequence.=" ".$forme;
          $longueur=3;
        }
      }
    }
    if ($longueur == 3) {


    print $sequence,"\n";

    }
}

 <% end %>
</label><br/><br/>





   <%= image_tag 'xsl.png', :class => "icon" %><B>2.2) Feuilles de Style XSL </B>


   <div class="explication"><p>	Les feuilles de style XSL permettent également l'extraction de patrons morphosyntaxiques selon le principe des templates qui matchent avec les noeuds définis dans des requêtes.

   </p></div><br/><br/>

 <P>2.2.1) Pour le patron NOM_ADJ</P>

   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM-ADJ_utf.xsl"} %>

  <% code("xml") do %>

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="2.0">
        <xsl:output method="text" encoding="utf-8"/>
        <xsl:template match="/">
        <xsl:apply-templates select="//element"/>
        </xsl:template>
        <xsl:template match="element">
            <xsl:choose>
                <xsl:when test="(./data[contains(text(),'NOM')]) and (following-sibling::element[1][./data[contains(text(),'ADJ')]])">
                    <xsl:value-of select="./data[3]"/>
                    <xsl:text> </xsl:text>
                </xsl:when>
                <xsl:when test="(./data[contains(text(),'ADJ')]) and (preceding-sibling::element[1][./data[contains(text(),'NOM')]])">
                    <xsl:value-of select="./data[3]"/>
                    <xsl:text>&#xA;</xsl:text>
                </xsl:when>
            </xsl:choose>
        </xsl:template>
</xsl:stylesheet>

 <% end %>
</label><br/><br/>



 <P>2.2.2) Pour le patron NOM_PREP_NOM</P>

   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM-PRP-NOM_utf.xsl"} %>

  <% code("xml") do %>

  <?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="1.0">
<xsl:output method="text" encoding="utf-8"/>
    <xsl:template match="/">
    <xsl:apply-templates select=".//article"/>
    </xsl:template>
    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(),'NOM')])">
                <xsl:variable name="p1" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'PRP')]]">
                    <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'NOM')]]">
                        <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                        <xsl:value-of select="$p1"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p2"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p3"/>
                    <xsl:text>&#xA;</xsl:text>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>

 <% end %>
</label><br/><br/>



 <P>2.2.3) Pour le patron DET_ADJ_NOM</P>

   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/DET-ADJ-NOM_utf.xsl"} %>

  <% code("xml") do %>

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="1.0">
    <xsl:output method="text" encoding="utf-8"/>
    <xsl:template match="/">
    <xsl:apply-templates select=".//article"/>
    </xsl:template>
    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(),'PRP:det')])">
                <xsl:variable name="p1" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'ADJ')]]">
                    <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'NOM')]]">
                        <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                        <xsl:value-of select="$p1"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p2"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p3"/>
                        <xsl:text>&#xA;</xsl:text>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>

 <% end %>
</label><br/><br/>

 <P>2.2.4) Pour le patron NOM_VER_KON</P>

   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM_VER_KON.xsl"} %>

  <% code("xml") do %>

  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      exclude-result-prefixes="xs"
      version="1.0">
  <xsl:output method="text" encoding="UTF-8"/>
      <xsl:template match="/">
          <xsl:apply-templates select=".//article"/>
      </xsl:template>
      <xsl:template match="article">
          <xsl:for-each select="element">
              <xsl:if test="(./data[1][contains(text(),'NOM')])">
                  <xsl:variable name="p1" select="./data[3]/text()"/>
                  <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'VER')]]">
                      <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                      <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'KON')]]">
                          <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                          <xsl:value-of select="$p1"/>
                          <xsl:text> </xsl:text>
                          <xsl:value-of select="$p2"/>
                          <xsl:text> </xsl:text>
                          <xsl:value-of select="$p3"/>
                      <xsl:text>&#xA;</xsl:text>
                      </xsl:if>
                  </xsl:if>
              </xsl:if>
          </xsl:for-each>
      </xsl:template>
  </xsl:stylesheet>





  <% end %>
 </label><br/><br/>



  <%= image_tag 'xquery.png', :class => "icon" %><B>2.3) Requêtes XQuery</B>

 <P>2.3.1) Pour le patron NOM_PRP_NOM</P>

   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM_PRP_NOM.xq"} %>


  <% code("xml") do %>
<corpus> { for $art in doc("numéro_de_la_rubrique")//article
for $elt in $art/element
let $nextelt := $elt/following-sibling::element[1]
let $nextelt2 := $nextelt/following-sibling::element[1]
where $elt/data[1] = "NOM" and $nextelt/data[1] = "PRP" and $nextelt2/data[1] = "NOM"
return <NOMPRPNOM>{$elt/data[2]/text(), " ", $nextelt/data[2]/text(), " ",$nextelt2/data[2]/text()}</NOMPRPNOM>
} </corpus>
<% end %>
</label><br/><br/>



  <P>2.3.2) Pour le patron ADJ_NOM </P><br/><br/>

    <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM_ADJ.xq"} %>


<% code("xml") do %>
<corpus> { for $art in doc("numéro_de_la_rubrique")//article
for $elt in $art/element
let $nextelt := $elt/following-sibling::element[1] where $elt/data[1] = "NOM" and $nextelt/data[1] = "ADJ"
return <NOMADJ>{$elt/data[3]/text(), " ", $nextelt/data[3]/text()}</NOMADJ> }
</corpus>
<% end %>
</label><br/><br/>


 <div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Vous trouverez dans ce tableau l'intégralité des résultats obtenus. Ils sont classés par patron, puis par étiqueteur afin de pouvoir comparer les résultats plus facilement.</p></div>

 <div class= "tableau"><table style="float:center">
   <tr>
     <th colspan="2">Patrons</th>
     <th>Rubrique 3476 (Cinéma)</th>
     <th>Rubrique 3232 (Idées)</th>
     <th>Rubrique 3260 (Livres)</th>
   </tr>
   <tr>
   <th rowspan="2">ADJ NOM / DET ADJ NOM</th>
   <td>Cordial</td>
   <td><a href="assets/ferial/RESULTATS/3476_CINEMA/ADJ_NOM/CORDIAL/ZIP_ADJ_NOM_CINEMA.zip" download>ZIP</a></td>
   <td></td>
   <td><a href="assets/ferial/RESULTATS/3260_LIVRES/ADJ_NOM/CORDIAL/ADJ_NOM_3260.txt" download>TXT</a></td>
   </tr>
   <tr>
     <td>Treetagger</td>
     <td><a href="assets/ferial/RESULTATS/3476_CINEMA/ADJ_NOM/TAGGER/ZIP_ADJ_NOM_CINEMA_TAGGER.zip" download>ZIP</a></td>
     <td><a href="assets/ferial/RESULTATS/3232_IDEES/ADJ_NOM/TAGGER/DET_ADJ_NOM_3232.txt" download>TXT</a></td>
     <td><a href="assets/ferial/RESULTATS/3260_LIVRES/ADJ_NOM/TAGGER/ZIP_ADJ_NOM_DET_ADJ_NOM_tagger.zip" download>TXT</a></td>
   </tr>
   <tr>
   <th rowspan="2">NOM ADJ</th>
   <td>Cordial</td>
   <td><a href="assets/ferial/RESULTATS/3476_CINEMA/NOM_ADJ/CORDIAL/ZIP_ADJ_NOM_CINEMA.zip" download>ZIP</a></td>
   <td></td>
   <td></a></td>
   </tr>
   <tr>
     <td>Treetagger</td>
     <td><a href="assets/ferial/RESULTATS/3476_CINEMA/NOM_ADJ/TAGGER/DET_ADJ_NOM_3476_tagger.zip" download>ZIP</a> <a href="assets/ferial/RESULTATS/nom_adj_co_cine.html" download>HTML</a></td>
     <td><a href="assets/ferial/RESULTATS/3232_IDEES/NOM_ADJ/TAGGER/xq_3232_NOM_ADJ.txt" download>TXT</a> <a href="assets/ferial/RESULTATS/nom_adj_co_3232.html" download>HTML</a></td>
     <td><a href="assets/ferial/RESULTATS/3260_LIVRES/NOM_ADJ/TAGGER/ZIP_NOM_ADJ_TAGGER_LIVRES" download>ZIP</a> <a href="assets/ferial/RESULTATS/nom_adj_3260co.html" download>HTML</a></td>
   </tr>
   <tr>
   <th rowspan="2">NOM VER KON / VER DET NOM</th>
   <td>Cordial</td>
   <td></td>
   <td><a href="assets/ferial/RESULTATS/3232_IDEES/NOM_VER_KON-VER_DET_NOM/CORDIAL/VER3232" download>TXT</a></td>
   <td></td>
   </tr>
   <tr>
     <td>Treetagger</td>
    <td></td>
    <td><a href="assets/ferial/RESULTATS/3232_IDEES/NOM_VER_KON-VER_DET_NOM/TAGGER/NOM_VER_KON-VER_DET_NOM.zip" download>ZIP</a></td>
    <td></td>
   </tr>

   <tr>
   <th rowspan="2">NOM PRP NOM</th>
   <td>Cordial</td>
   <td><a href="assets/ferial/RESULTATS/3476_CINEMA/NOM_PRP_NOM/CORDIAL/NOM_PRP_NOM_CINEMA_CORDIAL.zip" download>ZIP</a></td>
   <td><a href="assets/ferial/RESULTATS/3232_IDEES/NOM_PRP_NOM/CORDIAL/NOM_PRP_NOM_IDEES_CORDIAL.zip" download>ZIP</a></td>
   <td><a href="assets/ferial/RESULTATS/3260_LIVRES/NOM_PRP_NOM/CORDIAL/NOM-PREP-NOM3260.txt" download>TXT</a></td>
   </tr>
   <tr>
     <td>Treetagger</td>
     <td><a href="assets/ferial/RESULTATS/3476_CINEMA/NOM_PRP_NOM/TAGGER/NOM_PRP_NOM_CINEMA_TAGGER.zip" download>ZIP</a> <a href="assets/ferial/RESULTATS/nom_prp_nom_co_cine.html" download>HTML</a></td>
     <td><a href="assets/ferial/RESULTATS/3232_IDEES/NOM_PRP_NOM/TAGGER/TAG3232_NOM_PRP_NOM.zip" download>ZIP</a> <a href="assets/ferial/RESULTATS/nom_prp_nom_co_3232.html" download>HTML</a></td>
     <td><a href="assets/ferial/RESULTATS/3260_LIVRES/NOM_PRP_NOM/TAGGER/NOM_PRP_NOM_LIVRES_TAGGER.zip" download>TXT</a> <a href="assets/ferial/RESULTATS/nom_prp_nom_co_3260.html" download>HTML</a></td>
   </tr>
 </table></div><br/><br/>

 <%= partial "partials/h3", :locals => { :raccourci => "comp", :titre => "Comparaison des Résultats"} %>
 <%= partial "partials/onglets_bao_ferial" %><br/><br/>



  <div class="explication"><p>	A observer nos résultats, on relève une différence en raison des outils utilisés pour tagger nos deux types de fichiers. En effet, Si Cordial est précis et annote finement les tokens, TreeTagger ne détaille pas l'annotation pour le genre et le nombre pour les "NOM" et "ADJ", par exemple. De plus, il arrive à TreeTgger de confondre les homographes et de tagger un "VER" comme un "NOM". C'est précisément ce cas auquel on s'est confronté pour le verbe: estime à la troisième personne du singulier, TreeTagger l'a annoté comme étant un nom. Cela a par conséquent provoqué un écart important dans les résultats produits par les deux outils.<br/>
	  Cette disparité est probablement due au fait que Cordial est un correcteur orthagraphique français, tandis que TreeTagger est un outil allemand ayant été adapté à la langue française.


  </p></div><br/><br/><br/>



 <%= partial "partials/h3", :locals => { :raccourci => "bao4", :titre => "Boîte à outils 4 : Création des graphes"} %>
 <%= partial "partials/onglets_bao_ferial" %><br/><br/>

  <%= image_tag 'schema/bao_schema_4.png' %><br/><br/>

 	<p>Une fois les éléments obtenus et les résultats comparés, on utilisera les occurrences les plus pertinentes produites par la BAO3 pour en analyser les cooccurrents pour chaque rubrique et selon les thèmes choisis en visualisant les graphes générés par un programme fourni par M.Serge Fleury.

 <br/>Ce programme demande plusieurs arguments: "l'encodage des fichiers" + le fichier des patrons marphosyntaxiques extraits + fichier du motif recherché sous la forme de: MOTIF=Regex avec motif recherché.
 </p> <br/><br/>

 Rubrique 3476<em> Cinéma</em>.<br/><br/>

 Patron: <b>NOM_ADJ</b><br/>
 Motif: <b>(f|F)emmes? / (h|H)ommes?</b><br/>

<p>Ce choix est motivé par l'actualité qui a marqué le monde du cinéma en 2017, telle que <em>l'Affaire Weinstein</em> où des actrices américaines ont pu dénoncer publiquement les agressions sexuelles/viols dont elles ont été victimes et dont l'auteur n'est d'autre que le producteur américain Harvey Weinstein.
Cette affaire s'est étendue partout ailleurs dans le reste du monde, permettant ainsi à des actrices de lever l'omerta sur les cas d'agression et de harcèlement sexuels commis par les hommes de leur milieu professionnel.
On s'attend donc à avoir un environnement linguistique particulier autour des deux entités.
</p><br/><br/>Note: Clique droit sur 'Afficher l'image' pour agrandir l'image.<br/><br/><b>(f|F)emmes?</b><br/>

<%= image_tag 'ferial/graphes/femme.s.cinema-nom_adj.png' %><br/><br/>

Note: Clique droit sur 'Afficher l'image' pour agrandir l'image.<br/><br/><b>(h|H)ommes?</b><br/>

<%= image_tag 'ferial/graphes/homme.s.cine-adj-nom.png' %><br/><br/>

 <%= partial "partials/h3", :locals => { :raccourci => "analyse1", :titre => "Analyse 1"} %>
 <%= partial "partials/onglets_bao_ferial" %><br/><br/>

 <div class="explication"><p> L'affichage des deux graphes ne reflète finalement pas exactement ce quoi on s'attendait, si ce n'est 1 occurrence pour agissements d'hommes et 1 occurrence pour viol de femmes. Toutefois, on note bien que les cooccurrents des deux entités renforcent bien l'idée des rôles du genre attribués aux deux sexes par l'imaginaire collectif. En effet, le cooccurrent le plus important pour 'femme' est 'douce' (10), tandis que pour 'homme', 'intègre' arrive en première position avec (5) occurrences. De la même façon, le nombre de cooccurrents péjoratifs est plus élevé autour de 'femme.s' (jolies, en cuisine, coquettes, excommuniée) qu'autour d''homme.s'(exentrique).


 </p></div><br/><br/><br/>




<br/> - Rubrique 3232 <em>Idées</em>.<br/><br/>


 Patron: <b>NOM VER KON / VER DET NOM</b><br/>
 Motif: <b>.*estime? / .*explique.*</b><br/>

<p>Compte tenu de la spécificité de cette rubrique, on pense qu’elle comprendra un nombre important de verbes d’opinion, tels que estimer, considérer, etc. Autrement dit, une position subjective. Parallèlement, on pense qu’elle contiendra également des verbes argumentatifs, tels que: expliquer, analyser, etc. Contrairement aux premiers, ces derniers auront tendance à exprimer un avis plutôt objectif.

Pour le vérifier, nous avons compté et trié les occurrences grâce aux commandes UNIX. Les résultats affichent les verbes « estime » et « explique » comme les premiers dans le classement des verbes avec le nombre suivant:<br/><br/>

414 estime<br/>
351 explique<br/><br/>

La forme que prend le patron avec le verbe "estimer" est NOM VER KON, et celle avec le verbe "expliquer" est VER DET NOM. Le but derrière ce choix, est d'observer qui "estime" et qui "explique". </p>

<br/><br/>Note: Clique droit sur 'Afficher l'image' pour agrandir l'image.<br/><br/><b>.*estime?</b><br/>

<%= image_tag 'ferial/graphes/estime.s-idees.png' %><br/><br/>

Note: Clique droit sur 'Afficher l'image' pour agrandir l'image.<br/><br/><b>.*explique.*</b><br/>

<%= image_tag 'ferial/graphes/explique.ver.idees.png' %><br/><br/>

 <%= partial "partials/h3", :locals => { :raccourci => "analyse2", :titre => "Analyse 2"} %>
 <%= partial "partials/onglets_bao_ferial" %><br/><br/>

 <div class="explication"><p>Ce que l'on observe en premier est que le nombre des cooccurrents d'expliquer est plus élevé que celui d'estimer (explique, expliquent). Par ailleurs, le rôle du verbe "estimer" semble être d'introduire des noms propres ou des noms propres avec la profession de la personne dont les propos sont rapportés. Quant au rôle du verbe "expliquer", il semble se résumer à introduire exclusivement  des locuteurs en les qualifiant par leurs professions. En effet, on ne relève aucun nom propre lié à ce verbe. <br/>
	 Cela pourrait s'expliquer par la prise de distance, donc l'objectivité, exprimée par le verbe "expliquer", et par la prise de position, comme pour affirmer la subjectivité exprimée par le verbe "estimer".

 </p></div><br/><br/><br/>



 <br/> - Rubrique 3260 <em>Livres</em>.<br/><br/>


  Patron: <b>NOM PRP NOM</b><br/>
  Motif: <b>\bà\b</b><br/><br/>

Le choix de la préposition relève du registre qu'on pense être plus soutenu dans cette rubrique tourné vers un style littéraire. Pour confirmer cela, on va examiner le comportement linguistique et syntaxique de la préposition "à".<br/><br/>
<br/>


 <br/><br/>Note: Clique droit sur 'Afficher l'image' pour agrandir l'image.<br/><br/><b>\bà\b</b><br/>

 <%= image_tag 'ferial/graphes/a.prep.livres.png' %><br/><br/>



 <%= partial "partials/h3", :locals => { :raccourci => "analyse3", :titre => "Analyse 3"} %>
 <%= partial "partials/onglets_bao_ferial" %><br/><br/>

 <div class="explication"><p> L'usage de la préposition 'à' à est codifié syntaxiqument. En effet, elle est employée pour parler d’une tâche à effectuer, d'une description d'un lieu, d'une destination à des objets, d'une conséquence, de l'expression de la manière, de l'expression temporelle et spaciale, etc. Or dans ce ce cas et comme il a été souligné plus haut, on relève un emploi non-littéral et plus abstrait au vu du registre et du thème littéraire caratérisant cette rubrique: <em>hymne à la vie, hommage à la langue, antidote à la grisaille,etc. </em>

 </p></div><br/><br/><br/>

 <%= partial "partials/h3", :locals => { :raccourci => "conclu", :titre => "Conclusion"} %>
 <%= partial "partials/onglets_bao_ferial" %><br/><br/>


 <p>Tout d'abord, l'analyse de chaque motif en fonction de chaque rubrique a permis, d'une part, de mettre en évidence l'environnement lexical et sémantique de ceux-ci. D'autre part, elle a permis également de souligner leur comportement syntaxique dans un contexte journalistique spécifique. Si pour deux motifs l'hypothèse de départ a été invalidée, le reste des motifs a fourni des résultats plutôt satisfaisants. Cela peut s'expliquer par un mauvais choix du patron ou par un mauvais étiquetage de certains syntagmes. En effet, en dépit de la précision dont Cordial fait preuve, Il va avoir plus de difficulté à reconnaître certains syntagmes et les annotera comme NOM ADJ. Tandis que TreeTagger peut s'avérer plus précis dans son étiquetage pour certains syntagmes comme <em>"L'affaire Weinstein"</em> qui sera annotée comme une seule entité. Cela est probablement dû à la version du logiciel Cordial qui nous été fournie (datant de 1999).<br/> <br/>
 Par ailleurs, l'observation du comportement des motifs avec les graphes ne peut être suffisante à elle seule. Il manque donc une analyse plus poussée et une exploration textométrique plus détaillée qui permettrait l'observation des contextes droit et gauche sous forme de concordancier avec iTrameur ou Lexico. <br/><br/>
Enfin, j'ai pris beaucoup de plaisir à réaliser ce travail grâce à la manipulation des différentes boîtes à outils et grâce au travail collectif effectué en vue de la réalisation de ce site avec un nouveau langage de programmation.    </p>
<p>Vous pouvez également lire la <%= link_to("conclusion générale", "analyse.html",) %> du projet.</p>
