---
site:
  title: Projet BAO
  categorie: Travail de Milena Chaîne
  description: Projet de traitement automatique des langues, utilisant Perl et XSLT

author:
  all: Milena Chaîne, Margaux Duhayon, Ferial Yahiaoui
  milena: Milena Chaîne
  margaux: Margaux Duhayon
  ferial: Ferial Yahiaoui
  school: Inalco

master:
  site: "http://www.tal.univ-paris3.fr/plurital/"

patrons:
  cordial:
    - DETD[A-Z]{1,4}#NC[A-Z]{1,3}#NP[A-Z]{1,2}
    - DETD[A-Z]{1,4}#NC[A-Z]{1,3}#DETD[A-Z]{1,4}#NP[A-Z]{1,2}
    - ADV#V[A-Z]{1,6}#ADV
    - DETD[A-Z]{1,4}#NC[A-Z]{1,3}#ADJ[A-Z]{1,4}
    - DETD[A-Z]{1,4}#NCF[A-Z]{1,2}#ADJ[A-Z]{1,4}
    - DETD[A-Z]{1,4}#NCM[A-Z]{1,2}#ADJ[A-Z]{1,4}
    - DETD[A-Z]{1,4}#ADJ[A-Z]{1,4}#NC[A-Z]{1,3}
    - DETD[A-Z]{1,4}#ADJ[A-Z]{1,4}#NCF[A-Z]{1,2}
    - DETD[A-Z]{1,4}#ADJ[A-Z]{1,4}#NCM[A-Z]{1,2}
    - NC[A-Z]{1,3}#ADJ[A-Z]{1,4}
    - ADJ[A-Z]{1,4}#NC[A-Z]{1,3}
    - NC[A-Z]{1,3}#PREP#NC[A-Z]{1,3}
    - PREP#NP[A-Z]{1,2}
    - VINF#DETD[A-Z]{1,4}#NC[A-Z]{1,3}
    - VINF#DETD[A-Z]{1,4}#NC[A-Z]{1,3}#ADJ[A-Z]{1,4}
  treetagger:
    - DET:ART#NOM#NAM
    - DET:ART#NOM#DET:ART#NAM
    - ADV#VER:[a-z]{1,5}#ADV
    - DET:[A-Z]{1,3}#NOM#ADJ
    - DET:[A-Z]{1,3}#ADJ#NOM
    - NOM#ADJ
    - ADJ#NOM
    - NOM#PREP#NOM
    - PREP#NAM
    - VER:infi#DET:ART#NOM
    - VER:infi#DET:ART#NOM#ADJ
  xsl:
    - NOM ADJ
    - DET:ART NOM NAM
    - VER:infi DET:ART NOM ADJ
  xquery:
    - NOM PREP NOM
    - NOM ADJ

layout: milena
---

<% content_for :logo do %>
  <%= image_tag 'computer_bao.png' %>
<% end %>

<p>Cette page présente mes scripts d'extractions de rubriques, les patrons morpho-syntaxiques que j'ai choisis pour mon analyse, ainsi que les graphes que j'ai pu créer. Mon travail a suivi ce schéma :</p>
<%= image_tag 'schema/bao_schema.png' %>
<p>Comme indiqué sur la page d'accueil, j'ai choisi trois rubriques : Europe, International, et Société. Ces rubriques font partie des rubriques les plus générales du journal, et on peut s'attendre à ce que le style journalistique y soit relativement homogène (en comparaison par exemple avec les rubriques d'opinion ou de critique artistique et culturelle).</p>
<p>Tous les scripts sont visibles sur la page elle-même et téléchargeables. Pour naviguer entre les différentes boîtes à outils, vous pouvez utiliser la barre d'onglets ci-dessous. </p>

<%= partial "partials/h3", :locals => { :raccourci => "bao1_2", :titre => "Boîtes à outils 1 et 2 : création des fichiers"} %>
<%= partial "partials/onglets_bao_milena" %>

<%= image_tag 'schema/bao_schema_1_2.png' %>

<p>J'ai choisi de regrouper les boîtes à outils 1 et 2 en un seul script qui recueille en même temps les données recherchées dans l'arborescence de fils RSS et les étiquète avec Treetagger (l'étiquetage avec Cordial se fait à la main après avoir converti les fichiers en ISO-8859-1).</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Le programme en perl ci-dessous attend deux arguments : le numéro de la rubrique à traiter dans les fils RSS, et le chemin de l'arborescence contenant ces fils RSS. Il va ensuite</p>
<ul>
  <li>créer un fichier XML et un fichier TXT qui récupèreront nos données</li>
  <li>parcourir l'arborescence de fils RSS <b>(fonction parcoursarborescencefichiers)</b></li>
  <li>à chaque fois qu'il trouve un fichier XML correspondant à la rubrique recherchée, il en récupère le titre et le résumé et les nettoie <b>(fonction nettoyage)</b></li>
  <li>envoyer ces données nettoyées directement dans le fichier TXT (qui sera étiqueté par Cordial en dehors du programme)</li>
  <li>faire étiqueter ces mêmes données par TreeTagger et renvoie ce résultat dans le fichier XML <b>(fonction etiquetage)</b></li>
</ul></div>
<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/BAO1_2_milena_utf_8.pl"} %>
  <% code("perl") do %>
  #/usr/bin/perl

  # Milena Chaîne - 2017-2018
  # commande : perl BAO1_2_milena.pl repertoire_a_parcourir numero_de_la_rubrique
  # description : ce programme parcourt un répertoire (fonction parcoursarborescencefichiers)
  # quand il trouve un fichier xml contenant le numéro de la rubrique, il le nettoie (fonction nettoyage)
  # il renvoie les titres et descriptions non étiquetés dans un fichier texte
  # ensuite, il extrait les titres et descriptions des articles et les étiquète (fonction etiquetage, utilise treetagger)
  # ce résultat étiqueté est envoyé vers un fichier xml (programme treetagger2xml-utf8.pl) sous le format :
  # <item number="[numéro de l'article]">
  # <titre><document><article>[titre étiqueté]</article></document></titre>
  # <description><document><article>[description étiquetée]</article></document></description></item>
  #
  # données : le nom du répertoire contenant les fichiers à traiter, le numéro de rubrique à traiter
  # résultat : un fichier txt, un fichier xml, dans un répertoire nommé sortie

  my $test="Syntaxe : perl BAO1_2_milena.pl repertoire_a_parcourir numero_de_la_rubrique\n";

  if (@ARGV!=2) {
    die $test;
  }

  #récupération des arguments
  my ($rep, $rubrique) = @ARGV;
  $rep=~ s/[\/]$//; #on s'assure que le nom du répertoire ne se termine pas par un "/"

  #gestion de l'encodage
  my $encodage = "utf-8";

  my %liste= ();
  my $filecompteur = 1;
  my $itemcompteur = 0;


  #création du répertoire de sortie
  mkdir "sortie";
  open($sortie_xml, ">>:encoding($encodage)", ".\/sortie\/$rubrique.xml")
    || die "Impossible d'ouvrir $sortie_xml";
  open($sortie_txt, ">>:encoding($encodage)", ".\/sortie\/$rubrique.txt")
    || die "Impossible d'ouvrir $sortie_txt";

  print $sortie_xml "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n";
  print $sortie_xml "<PARCOURS>\n";
  print $sortie_xml "<NOM>Milena CHAINE</NOM>\n";
  print $sortie_xml "<FILTRAGE>\n";

  #-----------------------------------------------------------
  &parcoursarborescencefichiers($rep); #on lance la récursion qui se terminera après examen de toute l'arborescence

  #-----------------------------------------------------------
  print $sortie_xml "</FILTRAGE>\n";
  print $sortie_xml "</PARCOURS>\n";

  close $sortie_txt;
  close $sortie_xml;

  exit;

  #-----------------------------------------------------------
  sub nettoyage {
    my $var1 = shift(@_); #@_: liste des arguments d'une procédure
    my $var2 = shift(@_);
    my $var3 = shift(@_);
    my $var4 = shift(@_);
    my $var5 = shift(@_);
    my $var6 = shift(@_);
    my $var7 = shift(@_);

    $var1 =~s/&lt;.+?&gt;//g;
    $var2 =~s/&lt;.+?&gt;//g;
    $var3 =~ s/&#38;#39;/'/g;
    $var4 =~ s/&#039;/'/g;
    $var5 =~ s/\t+//gs;
    $var6 =~ s/> +</></g;
    $var7 =~ s/<[^>]+?>//g;
    return $var1,$var2,$var3,$var4,$var5,$var6,$var7;
  }

  #-----------------------------------------------------------
  sub etiquetage {
    my $var1 = shift(@_);
    my $var2 = shift(@_);

    open($titre_txt, ">:encoding($encodage)", ".\/sortie\/titre.txt")
      || die "Impossible d'ouvrir $titre_txt";

    open($description_txt, ">:encoding($encodage)", ".\/sortie\/description.txt")
      || die "Impossible d'ouvrir $description_txt";

  	print $titre_txt $var1;
  	print $titre_txt "\n";
  	print $description_txt $var2;
  	print $description_txt "\n";

  	close $titre_txt;
  	close $description_txt;

  	#traitement du titre
  	system("perl tokenise-utf8.pl ./sortie/titre.txt | /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/bin/tree-tagger -token -lemma -no-unknown /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/lib/french-utf8.par > ./sortie/titre_etiquette.txt");
  	system("perl treetagger2xml-utf8.pl ./sortie/titre_etiquette.txt utf8");

  	#traitement de la description
  	system("perl tokenise-utf8.pl ./sortie/description.txt | /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/bin/tree-tagger -token -lemma -no-unknown /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/lib/french-utf8.par > ./sortie/description_etiquette.txt");
  	system("perl treetagger2xml-utf8.pl ./sortie/description_etiquette.txt utf8");

  	local $/=undef; #pour pouvoir extraire le fichier xml en entier

  	#création de la variable contenant toutes les balises titre
  	open(TITRE, "<:encoding(utf8)","./sortie/titre_etiquette.txt.xml")
  		|| die "Impossible d'ouvrir le fichier txt converti en xml";
  	my $titre_etiquette=<TITRE>;
  	$titre_etiquette =~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;
  	close TITRE;

  	#création de la variable contenant toutes les balises description
  	open(DESC, "<:encoding(utf8)", "./sortie/description_etiquette.txt.xml")
  		|| die "Impossible d'ouvrir le fichier txt converti en xml";
  	my $description_etiquette=<DESC>;
  	$description_etiquette =~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;
  	close DESC;

  	return $titre_etiquette, $description_etiquette;
  }

  #-----------------------------------------------------------
  sub parcoursarborescencefichiers {
    my $path = shift(@_);
    opendir(DIR, $path)
      || die "Impossible d'ouvrir $path: $!\n";
    my @files = readdir(DIR);
    closedir(DIR);
    foreach my $file (@files) {

    	next if $file =~ /^\.\.?$/; #si $file est un fichier
    	$file = $path."/".$file;

    	#si $file est un répertoire
    	if (-d $file) {
    		print "<NOUVEAU REPERTOIRE> ==> ",$file,"\n";
    		&parcoursarborescencefichiers($file);	#récursivité : on va descendre dans l'arborescence et refaire la même opération
    		print "<FIN REPERTOIRE> ==> ",$file,"\n";
    	}

    	#si $file est un fichier
    	if (-f $file) {

    	  #si $file contient le nom de la rubrique
        if($file =~/$rubrique.+\.xml$/) {
          print "<",$filecompteur++,"> ==> ",$file,"\n";

          open (FICHIER, "<:encoding($encodage)", $file);
          my $ensemble="";

          #on récupère le contenu de chaque ligne
          while (my $ligne = <FICHIER>) {
            chomp $ligne;
            $ligne =~ s/\r//g;
            $ensemble = $ensemble . $ligne;
          }

          close FICHIER;

          #on récupère les titres et les descriptions
          while ($ensemble =~ m/<item>.*?<title>(.+?)<\/title>.*?<description>(.+?)<\/description>.*?<\/item>/g){
            my $titre = $1;
            my $description = $2;

            #s'ils n'ont pas déjà été traités
            if (!(exists $liste{$titre})) {
              $liste{$titre} = 1;

              #on nettoie le texte
              my ($titre_propre, $description_propre) = &nettoyage($titre, $description);

              #on étiquète le texte des titres et des descriptions avant de les réintégrer dans la sortie XML
              $itemcompteur++;
              my ($titre_etiquette, $description_etiquette) = &etiquetage($titre_propre, $description_propre);

              print $sortie_xml "<item number=\"$itemcompteur\">\n<titre>$titre_etiquette</titre>\n<description>$description_etiquette</description>\n</item>\n";
              print $sortie_txt "§ $titre\n$description\n\n";

            }
          }
        }
      }
    }
  }
  <% end %>
</label>

<div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Les fichiers que j'ai obtenus après avoir fait fonctionner ce programme pour chacune de mes rubriques et traité mes fichiers TXT avec le logiciel Cordial sont disponibles ici : <b><a href="assets/milena/archives_rss_3214_3210_3224.zip" download>ARCHIVE POUR LES RUBRIQUES 3210-3214-3224</a></b>.</p></div>
<p>Les fichiers XML étiquetés par TreeTagger se présentent ainsi :</p>
<%= image_tag 'milena/treetagger_ex.png' %>
<p>Les fichier TXT étiquetés par Cordial se présentent ainsi :</p>
<%= image_tag 'milena/cordial_ex.png' %>

<p>On voit bien qu'il va falloir traiter ces fichiers de façon différente pour pouvoir extraire des patrons. Ce travail est l'objet de la BAO 3.</p>

<%= partial "partials/h3", :locals => { :raccourci => "bao3", :titre => "Boîte à outils 3 : recherche des patrons"} %>
<%= partial "partials/onglets_bao_milena" %>

<%= image_tag 'schema/bao_schema_3.png' %>

<p>Cette boîte à outils a pour but de développer différentes méthodes d'extraction de patrons dans les fichiers obtenus précédemment. Cela nous permettra d'obtenir des résultats comparables pour Treetagger et Cordial, et d'expérimenter avec différents outils de traitement textuel. On abordera, dans l'ordre :
  <ul>
    <li><a href="milena.html#cordial">le traitement du fichier étiqueté par Cordial via Perl</a></li>
    <li><a href="milena.html#treetagger_perl">le traitement du fichier étiqueté par Treetagger via Perl</a></li>
    <li><a href="milena.html#treetagger_xslt">le traitement du fichier étiqueté par Treetagger via XSLT</a></li>
    <li><a href="milena.html#treetagger_xquery">le traitement du fichier étiqueté par Treetagger via XQuery</a></li>
  </ul></p>
<p>J'ai choisi les patrons que je souhaitais extraire en fonction des graphes que je souhaitais produire et des différences que je voulais observer entre Cordial et Treetagger. J'ai notamment extrait plusieurs patrons autour du modèle "déterminant-nom commun-nom propre" car je savais que je voulais essayer d'illustrer sous forme de graphes les formations linguistiques du type "l'affaire Fillon". J'ai également choisi un patron avec des verbes (à l'infinitif) pour pouvoir aussi analyser leur utilisation. La liste des patrons utilisés et des résultats obtenus est disponible en fin de BAO.</p>

<h4 id="cordial">CORDIAL ET PERL</h4>

<p>En inspectant le fichier étiqueté par Cordial, on se rend déjà compte que Cordial est un étiqueteur extrêmement fin (ce qui s'explique en partie par le fait qu'il s'agit d'un correcteur orthographique du français) : les noms communs, par exemple, sont étiquetés en fonction de leur genre et de leur nombre. J'ai donc choisi d'exploiter cette finesse d'analyse pour faire des distinctions dans les patrons que Treetagger n'autorise pas. J'ai choisi d'essayer d'utiliser une méthode différente de celles vues lors du cours  pour le travail en Perl.</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Le programme en perl ci-dessous attend trois arguments : le fichier txt traité par Cordial (converti en UTF-8), un fichier de patrons (sous forme d'expressions régulières) à extraire dans le fichier, et le numéro de la rubrique (pour nommer les fichiers). Il va ensuite</p>
<ul>
  <li>transformer le fichier txt en deux listes, l'une contenant tous les termes (c'est-à-dire la première colonne du fichier) et l'autre contenant toutes les étiquettes (la troisième colonne du fichier). La deuxième colonne du fichier (les lemmes) ne nous intéresse pas et sera ignorée</li>
  <li>pour chaque patron présent dans la liste de patrons :</li>
  <ul><li>transformer le patron en une liste d'étiquettes</li>
  <li>trouver une ligne où l'étiquette de la liste correspond à la première étiquette du patron, puis vérifier si la ligne suivante correspond à l'étiquette suivante, jusqu'à ce que le patron soit complété</li>
  <li>envoyer tous les patrons morpho-syntaxiques complets dans un fichier txt</b></li></ul>
</ul>
<p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Format du fichier de patrons :</p>
<table style="float:center">
  <% current_page.data.patrons.cordial.each do |patron| %>
  <tr><td><%= patron %></td></tr>
  <% end %>
</table></div>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/BAO3_cordial_milena.pl"} %>
  <% code("perl") do %>
  #/usr/bin/perl

  # Milena Chaîne - 2017-2018
  # commande : perl BAO3_cordial_milena.pl ./sortie_cordial/rubrique_cordial_utf8.txt fichier_patrons.txt numéro_rubrique
  # description : ce programme parcourt un fichier étiqueté par le logiciel Cordial et extrait des patrons morphosyntaxiques prédéfinis dans ce fichier
  # il transforme les données Cordial en deux listes de POS et de tokens
  # à chaque fois qu'il rencontre la POS qui constitue le début d'un motif, il essaie de le compléter et s'il y parvient il envoie le résultat dans un fichier txt
  # données : le fichier de sortie cordial (converti en UTF-8), un fichier txt contenant des patrons (sous forme de regexp) à rechercher par ligne, le numéro de la rubrique
  # résultat : un fichier txt (en UTF-8) contenant les patrons extraits dans le fichier cordial (une occurrence par ligne)

  #-----------------------------------------------------------
  use utf8;
  binmode STDOUT, ":utf8";

  my $test="Syntaxe : perl BAO3_cordial_milena.pl ./sortie_cordial/rubrique_cordial_utf8.txt fichier_patrons.txt numéro_rubrique\n";

  if (@ARGV!=3) {
    die $test;
  }

  open (CORDIAL,"<:encoding(utf-8)", $ARGV[0]);
  open (MOTIF,"<:encoding(utf-8)", $ARGV[1]);

  # on récupère le numéro de rubrique
  my $rubrique = $ARGV[2];

  # on extrait la liste de motifs
  @liste_motif = <MOTIF>;
  print "Liste des motifs recherchés\n";
  print @liste_motif;
  print "\n";

  close MOTIF;

  #-----------------------------------------------------------
  # transformation du fichier Cordial en listes de tokens et de POS
  my @liste_tokens=();
  my @liste_POS=();

  # pour chaque ligne du fichier
  while (my $ligne = <CORDIAL>) {
    #passer à la ligne suivante si la ligne ne correspond à notre schéma TOKEN LEMME POS
    next if ($ligne!~/^[^\t]+\t[^\t]+\t[^\t]+/);
    $ligne =~ s/\r//g;
    #récupérer la ligne
    chomp($ligne);
    #transformer la ligne en liste
    @liste=split(/\t/, $ligne);
    print "TOKEN : $liste[0]\tPOS : $liste[2]\n";
    #rajouter le token (premier élément de la ligne/liste) à la liste globale
    #de même pour la POS
    push(@liste_tokens , $liste[0]);
    push(@liste_POS, $liste[2]);
  }

  close CORDIAL;

  #-----------------------------------------------------------
  # on va créer un fichier différent
  foreach $motif (@liste_motif) {
    chomp ($motif);
    print "MOTIF : $motif\n";
    mkdir $rubrique;
    open($sortie, ">>:encoding(utf-8)", "./$rubrique/$motif.txt")
      || die "Impossible d'ouvrir $motif.txt";

    # transformer le motif en une liste de POS et vérifier le nombre de POS qu'il contient
    my @patron = split(/\#/, $motif);
    my $longueur_patron = scalar @patron;
    my $longueur_liste = scalar @liste_tokens;
    my $sequence = "";
    my $indice_liste = 0;
    my $indice_motif = 0;
    my $decalage = 0;

    # on va passer par chaque ligne/POS de notre fichier
    while ($indice_liste < $longueur_liste) {
      if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
        #on garde en mémoire où on en est dans la liste
        $decalage = $indice_liste;
        #on commence à composer le motif
        $sequence = $sequence.$liste_tokens[$indice_liste];

        # tant qu'il reste des POS à trouver pour compléter le patron
        while ($indice_motif < ($longueur_patron-1)) {
          $indice_liste++;
          $indice_motif++;
          # on cherche la POS suivante
          if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
            $sequence = $sequence." ".$liste_tokens[$indice_liste];
          }
          # si elle ne correspond pas au patron on sort et on se remet à zéro
          else {
            $decalage++;
            $indice_liste = $decalage;
            $sequence = "";
            $indice_motif = 0;
            last;
          }
        }

        # si on a complété un patron on l'imprime
        if ($sequence) {
          print "MOTIF TROUVE : $sequence\n";
          print $sortie "$sequence\n";
        }
        # on se remet à zéro
        $sequence = "";
        $indice_motif = 0;
        $decalage++;
        $indice_liste = $decalage;
      }
      # si la ligne qu'on traite ne correspond pas au début du motif on enchaîne
      else {
        $indice_liste++;
      }
    }
  }
  <% end %>
</label>

<h4 id="treetagger_perl">TREETAGGER ET PERL</h4>

<p>Après avoir obtenu des données exploitables avec Cordial et Perl, on peut passer aux fichiers XML étiquetées par Treetagger. La méthode Perl utilisée pour Treetagger est globalement similaire à celle que j'utilise pour Cordial ; l'extraction du patron est simplement différente car le format des lignes du fichier est différent. Les patrons extraits sont moins nombreux car Treetagger utilise moins d'étiquettes que Cordial.</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Le programme en perl ci-dessous attend trois arguments : le fichier XML contenant les étiquettes Treetagger, un fichier de patrons (sous forme d'expressions régulières) à extraire dans le fichier, et le numéro de la rubrique (pour nommer les fichiers). Son fonctionnement est presque identique au programme traitant la sortie Cordial, à l'exception de l'extraction des termes et des étiquettes, qui se fait directement dans le fichier XML. Le format des patrons est également différent car Treetagger n'utilise pas les mêmes étiquettes que Cordial.</p>
<p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Format du fichier de patrons :</p>
<table style="float:center">
  <% current_page.data.patrons.treetagger.each do |patron| %>
  <tr><td><%= patron %></td></tr>
  <% end %>
</table></div>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/BAO3_treetagger_milena.pl"} %>
  <% code("perl") do %>
  #/usr/bin/perl

  # Milena Chaîne - 2017-2018
  # commande : perl BAO3_treetagger_milena.pl ./sortie_cordial/rubrique_treetagger.xml fichier_patrons.txt numéro_rubrique
  # description : ce programme parcourt le fichier xml contenant des étiquettes treetagger et extrait des patrons morphosyntaxiques prédéfinis dans ce fichier
  # son fonctionnement est très similaire à celui du programme pour Cordial, l'extraction des POS/tokens se fait différemment en fonction de la structure de la ligne
  # données : le fichier XML traité par Treetagger, un fichier txt contenant des patrons (sous forme de regexp) à rechercher par ligne
  # résultat : un fichier txt (en UTF-8) contenant les patrons extraits dans le fichier (une occurrence par ligne)

  #-----------------------------------------------------------
  use utf8;
  binmode STDOUT, ":utf8";

  my $test="Syntaxe : perl BAO3_cordial_milena.pl ./sortie_cordial/rubrique_cordial_utf8.txt fichier_patrons.txt numéro_rubrique\n";

  if (@ARGV!=3) {
    die $test;
  }

  open (TREETAGGER,"<:encoding(utf-8)", $ARGV[0]);
  open (MOTIF,"<:encoding(utf-8)", $ARGV[1]);

  # on récupère le numéro de rubrique
  my $rubrique = $ARGV[2];

  # on extrait la liste de motifs
  @liste_motif = <MOTIF>;
  print "Liste des motifs recherchés\n";
  print @liste_motif;
  print "\n";

  close MOTIF;

  #-----------------------------------------------------------
  # transformation du fichier Treetagger en listes de tokens et de POS
  my @liste_tokens=();
  my @liste_POS=();

  # pour chaque ligne du fichier
  while (my $ligne = <TREETAGGER>) {
    #passer à la ligne suivante si la ligne n'est pas une ligne contenant un token
    next if ($ligne!~/^<element><data type="type">([^>]+)<\/data><data type="lemma">([^>]+)<\/data><data type="string">([^>]+)<\/data><\/element>/);
  	my $pos = $1;
  	my $token = $3;
    print "TOKEN : $token\tPOS : $pos\n";
    #rajouter le token (premier élément de la ligne/liste) à la liste globale
    #de même pour la POS
    push(@liste_tokens , $token);
    push(@liste_POS, $pos);
  }

  close TREETAGGER;

  #-----------------------------------------------------------
  # on va créer un fichier différent
  foreach $motif (@liste_motif) {
    chomp ($motif);
    print "MOTIF : $motif\n";
    mkdir $rubrique;
    open($sortie, ">>:encoding(utf-8)", "./$rubrique/TREETAGGER_$motif.txt")
      || die "Impossible d'ouvrir $motif.txt";

    # transformer le motif en une liste de POS et vérifier le nombre de POS qu'il contient
    my @patron = split(/\#/, $motif);
    my $longueur_patron = scalar @patron;
    my $longueur_liste = scalar @liste_tokens;
    my $sequence = "";
    my $indice_liste = 0;
    my $indice_motif = 0;
    my $decalage = 0;

    # on va passer par chaque ligne/POS de notre fichier
    while ($indice_liste < $longueur_liste) {
      if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
        #on garde en mémoire où on en est dans la liste
        $decalage = $indice_liste;
        #on commence à composer le motif
        $sequence = $sequence.$liste_tokens[$indice_liste];

        # tant qu'il reste des POS à trouver pour compléter le patron
        while ($indice_motif < ($longueur_patron-1)) {
          $indice_liste++;
          $indice_motif++;
          # on cherche la POS suivante
          if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
            $sequence = $sequence." ".$liste_tokens[$indice_liste];
          }
          # si elle ne correspond pas au patron on sort et on se remet à zéro
          else {
            $decalage++;
            $indice_liste = $decalage;
            $sequence = "";
            $indice_motif = 0;
            last;
          }
        }

        # si on a complété un patron on l'imprime
        if ($sequence) {
          print "MOTIF TROUVE : $sequence\n";
          print $sortie "$sequence\n";
        }
        # on se remet à zéro
        $sequence = "";
        $indice_motif = 0;
        $decalage++;
        $indice_liste = $decalage;
      }
      # si la ligne qu'on traite ne correspond pas au début du motif on enchaîne
      else {
        $indice_liste++;
      }
    }
  }
  <% end %>
</label>

<h4 id="treetagger_xslt">TREETAGGER ET XSLT</h4>

<p>Une autre méthode que l'on peut utiliser pour afficher des informations au format XML est une feuille de style XSL. Les feuilles de styles XSL permettent de formater et d'afficher des données XML dans un format HTML : l'enjeu est donc ici de produire une page HTMl facilement lisible à l'oeil nu. Les pages HTML créées sont disponibles en fin de BAO, et dans l'exercice 12 du projet de XML effectué dans le cadre du master.</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Les trois feuilles de style XSL ci-dessous sélectionnent les éléments correspondant à un patron dans les fichiers XML et les affichent sous forme de tableau. Ce travail a seulement été effectué sur quelques patrons car il prend un certain temps et n'est pas essentiel dans le cadre du projet. Ce travail a été réalisé en utilisant le logiciel Oxygen.</p>
<p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Patrons extraits, dans l'ordre (rubrique 3214) :</p>
<table style="float:center">
  <% current_page.data.patrons.xsl.each do |patron| %>
  <tr><td><%= patron %></td></tr>
  <% end %>
</table></div>
<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/xslt/exercice12_2_1.xsl"} %>
  <% code("xml") do %>
  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="1.0">
      <xsl:output method="html" encoding="UTF-8"/>
      <xsl:template match="/">
          <html>
              <body>
                  <h1>Extraction du patron NOM ADJ</h1>
                  <table>
                      <tr>
                          <td>
                              <xsl:apply-templates select="//item"/>
                          </td>
                      </tr>
                  </table>
              </body>
          </html>
      </xsl:template>
      <xsl:template match="item">
                  <xsl:apply-templates select="./titre/document/article/element"/>
      </xsl:template>
      <xsl:template match="element">
          <xsl:choose>
              <xsl:when
                  test="(./data[contains(text(), 'NOM')]) and (following-sibling::element[1][./data[contains(text(), 'ADJ')]])">
                  <xsl:value-of select="./data[3]"/>
                  <xsl:text> </xsl:text>
              </xsl:when>
              <xsl:when
                  test="(./data[contains(text(), 'ADJ')]) and (preceding-sibling::element[1][./data[contains(text(), 'NOM')]])">
                  <xsl:value-of select="./data[3]"/>
                  <xsl:text>&#xA;</xsl:text>
              </xsl:when>
          </xsl:choose>
      </xsl:template>
  </xsl:stylesheet>

  <% end %>
</label>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/xslt/exercice12_2_2.xsl"} %>
  <% code("xml") do %>
  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="1.0">
      <xsl:output method="text" encoding="utf-8"/>
      <xsl:template match="/">
          <html>
              <body>
                  <h1>Extraction du patron DET:ART NOM NAM</h1>
                  <table>
                      <tr>
                          <td>
                              <xsl:apply-templates select="//item"/>
                          </td>
                      </tr>
                  </table>
              </body>
          </html>
      </xsl:template>
      <xsl:template match="item">
                  <xsl:apply-templates select="./titre/document/article"/>
      </xsl:template>
      <xsl:template match="article">
          <xsl:for-each select="element">
              <xsl:if test="(./data[1][contains(text(), 'DET:ART')])">
                  <xsl:variable name="a" select="./data[3]/text()"/>
                  <xsl:if test="following-sibling::element[1][./data[1][contains(text(), 'NOM')]]">
                      <xsl:variable name="b" select="following-sibling::element[1]/data[3]/text()"/>
                      <xsl:if test="following-sibling::element[2][./data[1][contains(text(), 'NAM')]]">
                          <xsl:variable name="c" select="following-sibling::element[2]/data[3]/text()"/>
                          <xsl:value-of select="$a"/>
                          <xsl:text> </xsl:text>
                          <xsl:value-of select="$b"/>
                          <xsl:text> </xsl:text>
                          <xsl:value-of select="$c"/>
                          <xsl:text>&#xA;</xsl:text>
                      </xsl:if>
                  </xsl:if>
              </xsl:if>
          </xsl:for-each>
      </xsl:template>
  </xsl:stylesheet>

  <% end %>
</label>
<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/xslt/exercice12_2_3.xsl"} %>
  <% code("xml") do %>
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="html" encoding="utf-8"/>
    <xsl:template match="/">
        <html>
            <body>
                <h1>Extraction du patron VER:infi DET:ART NOM ADJ</h1>
                <table>
                    <tr>
                        <td>
                            <xsl:apply-templates select="//item"/>
                        </td>
                    </tr>
                </table>
            </body>
        </html>
        <xsl:apply-templates select=".//article"/>
    </xsl:template>
    <xsl:template match="item">
        <xsl:apply-templates select="./titre/document/article"/>
    </xsl:template>

    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(), 'VER:infi')])">
                <xsl:variable name="a" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(), 'DET:ART')]]">
                    <xsl:variable name="b" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(), 'NOM')]]">
                        <xsl:variable name="c" select="following-sibling::element[2]/data[3]/text()"/>
                        <xsl:if
                            test="following-sibling::element[3][./data[1][contains(text(), 'ADJ')]]">
                            <xsl:variable name="d"
                                select="following-sibling::element[3]/data[3]/text()"/>
                            <xsl:value-of select="$a"/>
                            <xsl:text> </xsl:text>
                            <xsl:value-of select="$b"/>
                            <xsl:text> </xsl:text>
                            <xsl:value-of select="$c"/>
                            <xsl:text> </xsl:text>
                            <xsl:value-of select="$d"/>
                            <xsl:text>&#xA;</xsl:text>
                        </xsl:if>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>

    </xsl:template>

</xsl:stylesheet>
<% end %>
</label>

<h4 id="treetagger_xquery">TREETAGGER ET XQUERY</h4>

<p>Les requêtes XQuery ci-dessous sont encore une autre méthode d'obtention de patrons. Xquery est le langage de requêtes associé à XML : chaque requête ci-dessous navigue dans l'arborescence du fichier XML et extrait les éléments définis.</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Ces requêtes ne sont pas téléchargeables en raison de leur brièveté et du fait que les patrons extraits ici proviennent du projet de XML et ne sont pas forcément pertinents à notre recherche.</p>
<p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Patrons extraits, dans l'ordre :</p>
<table style="float:center">
  <% current_page.data.patrons.xquery.each do |patron| %>
  <tr><td><%= patron %></td></tr>
  <% end %>
</table></div>

<label>

  <input id="more" type="checkbox">
  <p id="text-more">Afficher/masquer la requête</a></p>

<% code("xml") do %>
<corpus> { for $art in doc("numéro_de_la_rubrique")//article
for $elt in $art/element
let $nextelt := $elt/following-sibling::element[1]
let $nextelt2 := $nextelt/following-sibling::element[1]
where $elt/data[1] = "NOM" and $nextelt/data[1] = "PRP" and $nextelt2/data[1] = "NOM"
return <NOMPRPNOM>{$elt/data[2]/text(), " ", $nextelt/data[2]/text(), " ",$nextelt2/data[2]/text()}</NOMPRPNOM>
} </corpus>
<% end %>
</label>

<label>
  <input id="more" type="checkbox">
  <p id="text-more">Afficher/masquer la requête</a></p>
<% code("xml") do %>
<corpus> { for $art in doc("numéro_de_la_rubrique")//article
for $elt in $art/element
let $nextelt := $elt/following-sibling::element[1] where $elt/data[1] = "NOM" and $nextelt/data[1] = "ADJ"
return <NOMADJ>{$elt/data[3]/text(), " ", $nextelt/data[3]/text()}</NOMADJ> }
</corpus>
<% end %>
</label>

<div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Vous pouvez accéder  via le tableau suivant aux résultats utilisés pour l'analyse, au format TXT et HTML. Ils sont classés par motif, puis par étiqueteur afin de pouvoir comparer les résultats plus facilement. Vous pouvez également <b><a href="assets/milena/archives_etiquetage_3214_3210_3224.zip" download>télécharger une archive contenant tous les résultats obtenus</a></b>.</p></div>

<div class= "tableau"><table style="float:center">
  <tr>
    <th colspan="2">Motifs</th>
    <th>Rubrique 3210 (International)</th>
    <th>Rubrique 3214 (Europe)</th>
    <th>Rubrique 3224 (Société)</th>
  </tr>
  <tr>
  <th rowspan="2">DETERMINANT - NOM COMMUN - NOM PROPRE</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_DET_NC_NP.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_DET_NC_NP.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_DET_NC_NP.txt">TXT</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_DET_NC_NP.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_DET_NC_NP.txt">TXT</a>, <a href="assets/milena/xslt/exercice12_2_2.html">HTML</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_DET_NC_NP.txt">TXT</a></td>
  </tr>
  <tr>
  <th rowspan="2">DETERMINANT - NOM COMMUN - DETERMINANT - NOM PROPRE</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_DET_NC_DET_NP.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_DET_NC_DET_NP.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_DET_NC_DET_NP.txt">TXT</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_DET_NC_DET_NP.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_DET_NC_DET_NP.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_DET_NC_DET_NP.txt">TXT</a></td>
  </tr>
  <tr>
  <th rowspan="2">DETERMINANT - NOM - ADJECTIF</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_DET_NCF_ADJ.txt">TXT (féminin)</a>, <a href="assets/milena/perl/3210/CORDIAL_DET_NCM_ADJ.txt">TXT (masculin)</a>, <a href="assets/milena/perl/3210/CORDIAL_DET_NC_ADJ.txt">TXT (tous)</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_DET_NCF_ADJ.txt">TXT (féminin)</a>, <a href="assets/milena/perl/3214/CORDIAL_DET_NCM_ADJ.txt">TXT (masculin)</a>, <a href="assets/milena/perl/3214/CORDIAL_DET_NC_ADJ.txt">TXT (tous)</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_DET_NCF_ADJ.txt">TXT (féminin)</a>, <a href="assets/milena/perl/3224/CORDIAL_DET_NCM_ADJ.txt">TXT (masculin)</a>, <a href="assets/milena/perl/3224/CORDIAL_DET_NC_ADJ.txt">TXT (tous)</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_DET_NOM_ADJ.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_DET_NOM_ADJ.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_DET_NOM_ADJ.txt">TXT</a></td>
  </tr>
  <th rowspan="2">DETERMINANT - ADJECTIF - NOM</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_DET_ADJ_NCF.txt">TXT (féminin)</a>, <a href="assets/milena/perl/3210/CORDIAL_DET_ADJ_NCM.txt">TXT (masculin)</a>, <a href="assets/milena/perl/3210/CORDIAL_DET_ADJ_NC.txt">TXT (tous)</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_DET_ADJ_NCF.txt">TXT (féminin)</a>, <a href="assets/milena/perl/3214/CORDIAL_DET_ADJ_NCM.txt">TXT (masculin)</a>, <a href="assets/milena/perl/3214/CORDIAL_DET_ADJ_NC.txt">TXT (tous)</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_DET_ADJ_NCF.txt">TXT (féminin)</a>, <a href="assets/milena/perl/3224/CORDIAL_DET_ADJ_NCM.txt">TXT (masculin)</a>, <a href="assets/milena/perl/3224/CORDIAL_DET_ADJ_NC.txt">TXT (tous)</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_DET_ADJ_NOM.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_DET_ADJ_NOM.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_DET_ADJ_NOM.txt">TXT</a></td>
  </tr>
  <th rowspan="2">NOM - ADJECTIF</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_NC_ADJ.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_NC_ADJ.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_NC_ADJ.txt">TXT</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_NOM_ADJ.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_NOM_ADJ.txt">TXT</a>, <a href="assets/milena/xslt/exercice12_2_1.html">HTML</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_DET_NOM_ADJ.txt">TXT</a></td>
  </tr>
  <th rowspan="2">VERBE (INFINITIF) - DETERMINANT - NOM</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_VER_DET_NOM.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_VER_DET_NOM.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_VER_DET_NOM.txt">TXT</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_VER_DET_NOM.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_VER_DET_NOM.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_VER_DET_NOM.txt">TXT</a></td>
  </tr>
  <th rowspan="2">VERBE (INFINITIF) - DETERMINANT - NOM - ADJECTIF</th>
  <td>Cordial</td>
  <td><a href="assets/milena/perl/3210/CORDIAL_VER_DET_NC_ADJ.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3214/CORDIAL_VER_DET_NC_ADJ.txt">TXT</a></td>
  <td><a href="assets/milena/perl/3224/CORDIAL_VER_DET_NC_ADJ.txt">TXT</a></td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td><a href="assets/milena/perl/3210/TREETAGGER_VER_DET_NOM_ADJ.txt">TXT</a></td>
    <td><a href="assets/milena/perl/3214/TREETAGGER_VER_DET_NOM_ADJ.txt">TXT</a>, <a href="assets/milena/xslt/exercice12_2_3.html">HTML</a></td>
    <td><a href="assets/milena/perl/3224/TREETAGGER_VER_DET_NOM_ADJ.txt">TXT</a></td>
  </tr>
</table></div>
<p>On a donc obtenu nos fichiers, après avoir testé plusieurs méthodes d'extraction. Ici, celle qui est la plus adaptée à nos besoins est celle du script perl : il permet de traiter un grand nombre de patrons rapidement, et bien qu'il ne permette pas de raffiner la présentation des données comme XSLT, ceci n'est pas un problème ici puisque la BAO4 constituera justement le travail de mise en forme de ces données.</p>

<%= partial "partials/h3", :locals => { :raccourci => "bao4", :titre => "Boîte à outils 4 : création de graphes"} %>
<%= partial "partials/onglets_bao_milena" %>

<%= image_tag 'schema/bao_schema_4.png' %>
<p>Maintenant qu'on a récupéré nos données, on peut essayer de les interpréter avec des graphes. On effectue ce travail avec un programme dédié récupéré en cours, qui s'utilise sur Mac sous ce format :</p>
<figure>
<%= image_tag 'milena/graphe_ex.png' %>
<figcaption>chemin-absolu-vers-le-programme "encodage" fichier-a-traiter fichier-de-motif</figcaption>
</figure>
<p>Le fichier de motif doit se présenter de cette façon :</p>
<%= image_tag 'milena/motif_ex.png' %>

<p>Ici on doit se demander : que cherche-t-on à analyser avec ces données ? Je voulais trouver des exemples de différence d'analyse syntaxique entre Cordial et Treetagger, mais également choisir des motifs qui apporteraient des informations sur les rubriques choisies. Cette analyse n'est bien sûr pas exhaustive, et une présentation visuelle permet également d'influencer la perception des résultats, mais on peut quand même percevoir des indices qui pourraient aider à la formation d'une analyse plus complexe. Une explication plus détaillée des choix que nous avons effectués ensemble au cours de notre recherche en disponible dans la <%= link_to("page de conclusion", "analyse.html",) %>.</p>
<div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Vous pouvez cliquer sur les graphes ci-dessous pour les élargir. Il est également possible de <b><a href="assets/milena/graphes_milena.zip" download>télécharger une archive contenant tous les graphes obtenus</a></b> pour une lecture plus aisée.</p></div>
<h4 id="graphe_affaire">THÈME 1 : affaires et scandales</h4>

<p>Une des formations linguistiques que je souhaitais analyser dans mes rubriques est les groupes nominaux de type "déterminant-nom commun-nom propre" qui font référence à des scandales ou des affaires connues dans l'opinion publique. Je m'attendais notamment à retrouver un grand nombre de termes autour des affaires Fillon et Weinstein, mais j'ai été surprise de retrouver certaines formations.</p>
<p>J'ai choisi une expression régulière qui recherche les patrons contenant les termes "scandale", "affaire" et "cas", ainsi que les termes terminant par -gate (ex. Watergate). J'ai effectué cette recherche dans mes trois rubriques, sur les résultats étiquetés par Cordial et Treetagger.</p>
<p>On constate directement une grosse différence entre Cordial et Treetagger : Treetagger ne considère pas le l apostrophe comme un article. Tous les termes du type "l'affaire" sont donc ignorés dans notre patron. En règle générale, Treetagger est effectivement moins précis et surtout moins adapté aux spécificités du français que Cordial : cela s'explique par le fait que Cordial est un correcteur orthographique du français, alors que Treetagger est un outil beaucoup plus général qui bénéficie simplement d'une adaptation francophone.</p>
<figure>
<%= image_tag 'milena/graphes/affaire/3210_affaire_cordial.png' %>
<figcaption>Résultats avec Cordial sur la rubrique 3210</figcaption>
</figure>
<figure>
<%= image_tag 'milena/graphes/affaire/3210_affaire_treetagger.png' %>
<figcaption>Résultats avec Treetagger sur la rubrique 3210</figcaption>
</figure>
<p>Dans la rubrique "International", on retrouve, sans grande surprise, des évènements d'envergure internationale : "l'affaire Weinstein" est le motif revenant le plus souvent. On retrouve également les Panama papers, à la révélation desquels la rédaction du Monde a participé.</p>
<figure>
<%= image_tag 'milena/graphes/affaire/3214_affaire_cordial.png' %>
<figcaption>Résultats avec Cordial sur la rubrique 3214</figcaption>
</figure>
<figure>
<%= image_tag 'milena/graphes/affaire/3214_affaire_treetagger.png' %>
<figcaption>Résultats avec Treetagger sur la rubrique 3214</figcaption>
</figure>
<p>La rubrique "Europe" est en partie imbriquée dans la rubrique International dans l'organisation du journal, et une partie des articles trouvés dans cette dernière apparaissent dans les deux rubriques. On note cependant que les noms mentionnés ici ont une résonance plus européenne : l'affaire Tariq Ramadan qui a touché principalement la France et le Royaume-Uni, et les affaires Gürtel et Puidgemont qui se déroulent en Espagne et en Catalogne.</p>
<figure>
<%= image_tag 'milena/graphes/affaire/3224_affaire_cordial.png' %>
<figcaption>Résultats avec Cordial sur la rubrique 3224</figcaption>
</figure>
<figure>
<%= image_tag 'milena/graphes/affaire/3224_affaire_treetagger.png' %>
<figcaption>Résultats avec Treetagger sur la rubrique 3224</figcaption>
</figure>
<p>La rubrique "Société" est une rubrique assez large qui a tendance à reprendre les évènements à la une sous un angle différent. On notera l'ensemble des termes liés à l'affaire Fillon (qui est devenue "les affaires Fillon" et "l'affaire Penelope Fillon") ; cependant, ce motif a été analysé plus en détail par Margaux dans la rubrique "Politique".</p>
<p>On note que les évènements discutés ici ont principalement une portée française, à l'exception de l'affaire Weinstein, qui revient le plus souvent, et bien plus souvent que dans les rubriques généralistes vues plus haut. Le reste des termes concerne en partie des évènements politiques (Fillon, Cahuzac...), mais on note qu'un grand nombre des affaires mentionnées dans la rubrique "Société" sont, au sens large, des "faits divers" : des évènements ayant choqué l'opinion et souvent lancé des débats de société. Les meilleurs exemples ici sont probablement les affaires Grégory et Maëlys, l'affaire Jacqueline Sauvage et l'affaire Théo, dont le déroulement avait alimenté des débats sur, respectivement, les erreurs judiciaires, les violences domestiques et les violences policières.</p>
<p>Que l'affaire Weinstein soit omniprésente dans ce graphe révèle l'angle choisi par le Monde pour la traiter : un sujet de société qui alimenta ensuite un mouvement de protestation et un débat sur la notion de harcèlement sexuel. On se souviendra que c'est le Monde qui a publié en janvier 2018 (dans la rubrique "Idées" et non "Société") la tribune controversée d'une centaine de femmes sur la "liberté d'importuner" dans le cadre du mouvement #metoo.</p>

<h4 id="graphe_affaire">THÈME 2 : l'Union européenne</h4>
<p>Une conséquence d'avoir travaillé sur la rubrique "Europe" est que j'ai pu observer même à l'œil nu l'influence du Brexit dans les rubriques. D'une façon générale, l'Union européenne, son statut, ses lois et ses membres ont occupé une forte place dans l'opinion en 2017 : conséquence du Brexit mais également des élections présidentielles. J'ai choisi de travailler sur le patron "verbe à l'infinitif-déterminant-nom-adjectif" et de chercher les occurrences de l'adjectif "européen", pour voir quelles actions étaient associées à l'Union européenne. Encore une fois, la forte différence entre les deux étiquetages est due au fait que Treetagger n'a reconnu aucune occurrence contenant des l apostrophes.</p>

<figure>
<%= image_tag 'milena/graphes/europe/3214_europe_cordial.png' %>
<figcaption>Résultats avec Cordial sur la rubrique 3214</figcaption>
</figure>
<figure>
<%= image_tag 'milena/graphes/europe/3214_europe_treetagger.png' %>
<figcaption>Résultats avec Treetagger sur la rubrique 3214</figcaption>
</figure>
<p>On retrouve plusieurs influences dans ces résultats qui sont déjà assez conséquents :</p>
  <ul>
    <li>des termes liés au Brexit : "quitter l'Union européenne", "respecter les traités européens", "rassurer les ressortissants européens"...</li>
    <li>une contre-réaction à la sortie de Royaume-Uni de l'UE, qui a engendré force débats pendant la campagne présidentielle. On retrouve des termes tels que "l'édifice", "le projet", "l'identité", "l'idée", "la coopération", "la dynamique" et "l'idéal" européens, qui doivent être sauvés, consolidés, reconstruits, renforcés, préservés...Ce lexique est de loin le plus présent dans le graphe.</li>
    <li>enfin, on retrouve aussi des termes plus pragmatiques et économiques dans le graphe, comme "croissance", "financements" et "partenariats"</li>
  </ul>

<h4 id="graphe_affaire">THÈME 3 : mouvements et mouvances</h4>
<p>Le dernier motif que j'ai choisi a été l'occasion d'explorer les patrons de type "nom-adjectif". J'ai choisi de chercher le motif "mouvement" dans les rubriques "International" et "Société" car peu d'interférences de sens me semblaient probables (telles que l'emploi du terme "mouvement" au sens littéral). Je souhaitais notamment voir s'il était possible de voir si les adjectifs qui accompagnaient le terme étaient péjoratifs ou mélioratifs.</p>
<figure>
<%= image_tag 'milena/graphes/mvt/3210_mvt_cordial.png' %>
<figcaption>Résultats avec Cordial sur la rubrique 3210</figcaption>
</figure>
<figure>
<%= image_tag 'milena/graphes/mvt/3210_mvt_treetagger.png' %>
<figcaption>Résultats avec Treetagger sur la rubrique 3210</figcaption>
</figure>
<p>On notera ici que Cordial et Treetagger sont pour une fois à égalité en termes d'occurrences trouvées. Treetagger a même détecté une occurrence pertinente, "metoo", que Cordial a ignorée. D'une façon générale, j'ai eu l'impression en travaillant sur ce corpus que, Cordial étant un correcteur orthographique (par ailleurs assez daté), il est parfois normatif au point d'ignorer les occurrences qui ne correspondent pas à du français "traditionnel".</p>
<p>Ici, aucun des étiqueteurs n'a "raison" (Treetagger identifie un adjectif et Cordial un nom), mais la solution proposée par Treetagger me semble être la meilleure ici (un nom est plus souvent suivi d'un adjectif que d'un autre nom en français, et "#metoo" qualifie le terme "mouvement" : il est souvent employé avec d'autres adjectifs, comme "le mouvement féministe #metoo"). En m'intéressant au <%= link_to("fonctionnement de Treetagger", "http://www.cis.uni-muenchen.de/~schmid/tools/TreeTagger/data/tree-tagger1.pdf",) %>, j'ai pu apprendre que ce dernier utilise des arbres de décision pour effectuer ses étiquetages, et le cas donné ici me semble être un bon exemple de ce fonctionnement. Il est beaucoup plus difficile de trouver des informations sur le logiciel Cordial car il n'est pas libre ; je n'ai donc pas pu comparer les deux logiciels sous cet angle-ci. </p>
<p>On notera également dans les graphes eux-mêmes qu'à l'exception de l'adjectif "antiraciste" (et à la rigueur "pacifiste"), les adjectifs associés à "mouvement" dans la rubrique "International" sont fortement politisés.</p>
<figure>
<%= image_tag 'milena/graphes/mvt/3224_mvt_cordial.png' %>
<figcaption>Résultats avec Cordial sur la rubrique 3224</figcaption>
</figure>
<figure>
<%= image_tag 'milena/graphes/mvt/3224_mvt_treetagger.png' %>
<figcaption>Résultats avec Treetagger sur la rubrique 3224</figcaption>
</figure>
<p>La rubrique "Société" nous offre une image légèrement différente : les termes employés sont liés aux questions et dynamiques sociales (on note l'apparition du terme "féministe" et le retour de "metoo") et certains adjectifs qualifient les mouvements : "inédit", "spontané"... Une différence de registre et de thème qui nous renseigne sur les priorités des articles de la rubrique.</p>
<%= partial "partials/h3", :locals => { :raccourci => "conclu", :titre => "Conclusion"} %>
<%= partial "partials/onglets_bao_milena" %>
<p>J'ai abordé ce projet sous l'angle d'un travail de comparaisons entre différents outils et j'ai essayé de centrer mon analyse des outils linguistiques autour de cette question. Cependant, pour mon travail sur les graphes, j'ai préféré choisir des hypothèses de départ (ex.une rubrique telle que "Société" traitera de nombre de faits et scandales choquants) et essayer de les confirmer ou de les infirmer via les graphes. Un outil visuel comme celui-ci est une arme à double tranchant car si elle peut fortement faciliter la lecture de données elle l'influence aussi énormément par sa présentation, en renforçant nos biais de confirmation. C'est une difficulté que j'ai fait mon possible pour contrer. </p>
<p>Si je devais approfondir mon analyse, je choisirai probablement un des thèmes que j'ai abordés et centrerais tous mes patrons autour de ce dernier pour pouvoir obtenir son environnement linguistique complet. Cependant, je suis satisfaite d'avoir aussi pu effectuer des comparaisons entre différents rubriques et thèmes.</p>
<p>J'aurais aussi souhaité pouvoir poursuivre ma comparaison de Treetagger et Cordial, notamment en comparant leurs fichiers étiquetés pour pouvoir classer les différences trouvées.</p>
<p>Je vous invite également à lire la <%= link_to("conclusion générale", "analyse.html",) %> du projet.</p>
