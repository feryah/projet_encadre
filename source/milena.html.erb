---
site:
  title: Projet BAO
  categorie: Travail de Milena Chaîne
  description: Projet de traitement automatique des langues, utilisant Perl et XSLT

author:
  all: Milena Chaîne, Margaux Duhayon, Ferial Yahiaoui
  milena: Milena Chaîne
  margaux: Margaux Duhayon
  ferial: Ferial Yahiaoui
  school: Inalco

master:
  site: "http://www.tal.univ-paris3.fr/plurital/"

patrons:
  cordial:
    - DETD[A-Z]{1,4}#NC[A-Z]{1,3}#NP[A-Z]{1,2}
    - DETD[A-Z]{1,4}#NC[A-Z]{1,3}#DETD[A-Z]{1,4}#NP[A-Z]{1,2}
    - DETD[A-Z]{1,4}#NC[A-Z]{1,3}#ADJ[A-Z]{1,4}
    - DETD[A-Z]{1,4}#NCF[A-Z]{1,2}#ADJ[A-Z]{1,4}
    - DETD[A-Z]{1,4}#NCM[A-Z]{1,2}#ADJ[A-Z]{1,4}
    - DETD[A-Z]{1,4}#ADJ[A-Z]{1,4}#NC[A-Z]{1,3}
    - DETD[A-Z]{1,4}#ADJ[A-Z]{1,4}#NCF[A-Z]{1,2}
    - DETD[A-Z]{1,4}#ADJ[A-Z]{1,4}#NCM[A-Z]{1,2}
    - NC[A-Z]{1,3}#ADJ[A-Z]{1,4}
    - ADJ[A-Z]{1,4}#NC[A-Z]{1,3}
    - NC[A-Z]{1,3}#PREP#NC[A-Z]{1,3}
    - VINF#DETD[A-Z]{1,4}#NC[A-Z]{1,3}
    - VINF#DETD[A-Z]{1,4}#NC[A-Z]{1,3}#ADJ[A-Z]{1,4}
  treetagger:
    - DET:ART#NOM#NAM
    - DET:ART#NOM#DET:ART#NAM
    - ADV#VER:[a-z]{1,5}#ADV
    - DET:[A-Z]{1,3}#NOM#ADJ
    - DET:[A-Z]{1,3}#ADJ#NOM
    - NOM#ADJ
    - ADJ#NOM
    - NOM#PREP#NOM
    - PREP#NAM
    - VER:infi#DET:ART#NOM
    - VER:infi#DET:ART#NOM#ADJ

layout: milena
---

<% content_for :logo do %>
  <%= image_tag 'computer_bao.png' %>
<% end %>

<p>Cette page présente mes scripts d'extractions de rubriques, les patrons morpho-syntaxiques que j'ai choisis pour mon analyse, ainsi que les graphes que j'ai pu créer. Mon travail a suivi ce schéma :</p>
<%= image_tag 'schema/bao_schema.png' %>
<p>Comme indiqué sur la page d'accueil, j'ai choisi trois rubriques : Europe, International, et Société. Ces rubriques font partie des rubriques les plus générales du journal, et on peut s'attendre à ce que le style journalistique y soit relativement homogène (en comparaison par exemple avec les rubriques d'opinion ou de critique artistique et culturelle).</p>
<p>Tous les scripts sont visibles sur la page elle-même et téléchargeables. Pour naviguer entre les différentes boîtes à outils, vous pouvez utiliser la barre d'onglets ci-dessous. </p>

<%= partial "partials/h3", :locals => { :raccourci => "bao1_2", :titre => "Boîtes à outils 1 et 2 : création des fichiers"} %>
<%= partial "partials/onglets_milena" %>

<%= image_tag 'schema/bao_schema_1_2.png' %>

<p>J'ai choisi de regrouper les boîtes à outils 1 et 2 en un seul script qui recueille en même temps les données recherchées dans l'arborescence de fils RSS et les étiquète avec Treetagger (l'étiquetage avec Cordial se fait à la main après avoir converti les fichiers en ISO-8859-1).</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Le programme en perl ci-dessous attend deux arguments : le numéro de la rubrique à traiter dans les fils RSS, et le chemin de l'arborescence contenant ces fils RSS. Il va ensuite
<ul>
  <li>créer un fichier XML et un fichier TXT qui récupèreront nos données</li>
  <li>parcourir l'arborescence de fils RSS <b>(fonction parcoursarborescencefichiers)</b></li>
  <li>à chaque fois qu'il trouve un fichier XML correspondant à la rubrique recherchée, il en récupère le titre et le résumé et les nettoie <b>(fonction nettoyage)</b></li>
  <li>envoyer ces données nettoyées directement dans le fichier TXT (qui sera étiqueté par Cordial en dehors du programme)</li>
  <li>faire étiqueter ces mêmes données par TreeTagger et renvoie ce résultat dans le fichier XML <b>(fonction etiquetage)</b></li>
</ul></p></div>
<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/BAO1_2_milena_utf_8.pl"} %>
  <% code("perl") do %>
  #/usr/bin/perl

  # Milena Chaîne - 2017-2018
  # commande : perl BAO1_2_milena.pl repertoire_a_parcourir numero_de_la_rubrique
  # description : ce programme parcourt un répertoire (fonction parcoursarborescencefichiers)
  # quand il trouve un fichier xml contenant le numéro de la rubrique, il le nettoie (fonction nettoyage)
  # il renvoie les titres et descriptions non étiquetés dans un fichier texte
  # ensuite, il extrait les titres et descriptions des articles et les étiquète (fonction etiquetage, utilise treetagger)
  # ce résultat étiqueté est envoyé vers un fichier xml (programme treetagger2xml-utf8.pl) sous le format :
  # <item number="[numéro de l'article]">
  # <titre><document><article>[titre étiqueté]</article></document></titre>
  # <description><document><article>[description étiquetée]</article></document></description></item>
  #
  # données : le nom du répertoire contenant les fichiers à traiter, le numéro de rubrique à traiter
  # résultat : un fichier txt, un fichier xml, dans un répertoire nommé sortie

  my $test="Syntaxe : perl BAO1_2_milena.pl repertoire_a_parcourir numero_de_la_rubrique\n";

  if (@ARGV!=2) {
    die $test;
  }

  #récupération des arguments
  my ($rep, $rubrique) = @ARGV;
  $rep=~ s/[\/]$//; #on s'assure que le nom du répertoire ne se termine pas par un "/"

  #gestion de l'encodage
  my $encodage = "utf-8";

  my %liste= ();
  my $filecompteur = 1;
  my $itemcompteur = 0;


  #création du répertoire de sortie
  mkdir "sortie";
  open($sortie_xml, ">>:encoding($encodage)", ".\/sortie\/$rubrique.xml")
    || die "Impossible d'ouvrir $sortie_xml";
  open($sortie_txt, ">>:encoding($encodage)", ".\/sortie\/$rubrique.txt")
    || die "Impossible d'ouvrir $sortie_txt";

  print $sortie_xml "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n";
  print $sortie_xml "<PARCOURS>\n";
  print $sortie_xml "<NOM>Milena CHAINE</NOM>\n";
  print $sortie_xml "<FILTRAGE>\n";

  #-----------------------------------------------------------
  &parcoursarborescencefichiers($rep); #on lance la récursion qui se terminera après examen de toute l'arborescence

  #-----------------------------------------------------------
  print $sortie_xml "</FILTRAGE>\n";
  print $sortie_xml "</PARCOURS>\n";

  close $sortie_txt;
  close $sortie_xml;

  exit;

  #-----------------------------------------------------------
  sub nettoyage {
    my $var1 = shift(@_); #@_: liste des arguments d'une procédure
    my $var2 = shift(@_);
    my $var3 = shift(@_);
    my $var4 = shift(@_);
    my $var5 = shift(@_);
    my $var6 = shift(@_);
    my $var7 = shift(@_);

    $var1 =~s/&lt;.+?&gt;//g;
    $var2 =~s/&lt;.+?&gt;//g;
    $var3 =~ s/&#38;#39;/'/g;
    $var4 =~ s/&#039;/'/g;
    $var5 =~ s/\t+//gs;
    $var6 =~ s/> +</></g;
    $var7 =~ s/<[^>]+?>//g;
    return $var1,$var2,$var3,$var4,$var5,$var6,$var7;
  }

  #-----------------------------------------------------------
  sub etiquetage {
    my $var1 = shift(@_);
    my $var2 = shift(@_);

    open($titre_txt, ">:encoding($encodage)", ".\/sortie\/titre.txt")
      || die "Impossible d'ouvrir $titre_txt";

    open($description_txt, ">:encoding($encodage)", ".\/sortie\/description.txt")
      || die "Impossible d'ouvrir $description_txt";

  	print $titre_txt $var1;
  	print $titre_txt "\n";
  	print $description_txt $var2;
  	print $description_txt "\n";

  	close $titre_txt;
  	close $description_txt;

  	#traitement du titre
  	system("perl tokenise-utf8.pl ./sortie/titre.txt | /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/bin/tree-tagger -token -lemma -no-unknown /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/lib/french-utf8.par > ./sortie/titre_etiquette.txt");
  	system("perl treetagger2xml-utf8.pl ./sortie/titre_etiquette.txt utf8");

  	#traitement de la description
  	system("perl tokenise-utf8.pl ./sortie/description.txt | /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/bin/tree-tagger -token -lemma -no-unknown /Users/milena/Documents/Travail/M1TAL/PROJET_BAO/tree-tagger/lib/french-utf8.par > ./sortie/description_etiquette.txt");
  	system("perl treetagger2xml-utf8.pl ./sortie/description_etiquette.txt utf8");

  	local $/=undef; #pour pouvoir extraire le fichier xml en entier

  	#création de la variable contenant toutes les balises titre
  	open(TITRE, "<:encoding(utf8)","./sortie/titre_etiquette.txt.xml")
  		|| die "Impossible d'ouvrir le fichier txt converti en xml";
  	my $titre_etiquette=<TITRE>;
  	$titre_etiquette =~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;
  	close TITRE;

  	#création de la variable contenant toutes les balises description
  	open(DESC, "<:encoding(utf8)", "./sortie/description_etiquette.txt.xml")
  		|| die "Impossible d'ouvrir le fichier txt converti en xml";
  	my $description_etiquette=<DESC>;
  	$description_etiquette =~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;
  	close DESC;

  	return $titre_etiquette, $description_etiquette;
  }

  #-----------------------------------------------------------
  sub parcoursarborescencefichiers {
    my $path = shift(@_);
    opendir(DIR, $path)
      || die "Impossible d'ouvrir $path: $!\n";
    my @files = readdir(DIR);
    closedir(DIR);
    foreach my $file (@files) {

    	next if $file =~ /^\.\.?$/; #si $file est un fichier
    	$file = $path."/".$file;

    	#si $file est un répertoire
    	if (-d $file) {
    		print "<NOUVEAU REPERTOIRE> ==> ",$file,"\n";
    		&parcoursarborescencefichiers($file);	#récursivité : on va descendre dans l'arborescence et refaire la même opération
    		print "<FIN REPERTOIRE> ==> ",$file,"\n";
    	}

    	#si $file est un fichier
    	if (-f $file) {

    	  #si $file contient le nom de la rubrique
        if($file =~/$rubrique.+\.xml$/) {
          print "<",$filecompteur++,"> ==> ",$file,"\n";

          open (FICHIER, "<:encoding($encodage)", $file);
          my $ensemble="";

          #on récupère le contenu de chaque ligne
          while (my $ligne = <FICHIER>) {
            chomp $ligne;
            $ligne =~ s/\r//g;
            $ensemble = $ensemble . $ligne;
          }

          close FICHIER;

          #on récupère les titres et les descriptions
          while ($ensemble =~ m/<item>.*?<title>(.+?)<\/title>.*?<description>(.+?)<\/description>.*?<\/item>/g){
            my $titre = $1;
            my $description = $2;

            #s'ils n'ont pas déjà été traités
            if (!(exists $liste{$titre})) {
              $liste{$titre} = 1;

              #on nettoie le texte
              my ($titre_propre, $description_propre) = &nettoyage($titre, $description);

              #on étiquète le texte des titres et des descriptions avant de les réintégrer dans la sortie XML
              $itemcompteur++;
              my ($titre_etiquette, $description_etiquette) = &etiquetage($titre_propre, $description_propre);

              print $sortie_xml "<item number=\"$itemcompteur\">\n<titre>$titre_etiquette</titre>\n<description>$description_etiquette</description>\n</item>\n";
              print $sortie_txt "§ $titre\n$description\n\n";

            }
          }
        }
      }
    }
  }
  <% end %>
</label>

<div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Les fichiers que j'ai obtenus après avoir fait fonctionner ce programme pour chacune de mes rubriques et traité mes fichiers TXT avec le logiciel Cordial sont disponibles ici : <b><a href="assets/milena/archives_rss_3214_3210_3224.zip" download>ARCHIVE POUR LES RUBRIQUES 3210-3214-3224</a></b>.</p></div>
<p>Les fichiers XML étiquetés par TreeTagger se présentent ainsi :</p>
<%= image_tag 'milena/treetagger_ex.png' %>
<p>Les fichier TXT étiquetés par Cordial se présentent ainsi :</p>
<%= image_tag 'milena/cordial_ex.png' %>

<p>On voit bien qu'il va falloir traiter ces fichiers de façon différente pour pouvoir extraire des patrons. Ce travail est l'objet de la BAO 3.</p>

<%= partial "partials/h3", :locals => { :raccourci => "bao3", :titre => "Boîte à outils 3 : recherche des patrons"} %>
<%= partial "partials/onglets_milena" %>

<%= image_tag 'schema/bao_schema_3.png' %>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>

<h4 id="cordial">CORDIAL ET PERL</h4>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Le programme en perl ci-dessous attend trois arguments : le fichier txt traité par Cordial (converti en UTF-8), un fichier de patrons (sous forme d'expressions régulières) à extraire dans le fichier, et le numéro de la rubrique (pour nommer les fichiers). Il va ensuite
<ul>
  <li>transformer le fichier txt en deux listes, l'une contenant tous les termes (c'est-à-dire la première colonne du fichier) et l'autre contenant toutes les étiquettes (la troisième colonne du fichier). La deuxième colonne du fichier (les lemmes) ne nous intéresse pas et sera ignorée</li>
  <li>pour chaque patron présent dans la liste de patrons :</li>
  <ul><li>transformer le patron en une liste d'étiquettes</li>
  <li>trouver une ligne où l'étiquette de la liste correspond à la première étiquette du patron, puis vérifier si la ligne suivante correspond à l'étiquette suivante, jusqu'à ce que le patron soit complété</li>
  <li>envoyer tous les patrons morpho-syntaxiques complets dans un fichier txt</b></li></ul>
</ul></p>
<p>Format du fichier de patrons :</p>
<table style="float:center">
  <% current_page.data.patrons.cordial.each do |patron| %>
  <tr><td><%= patron %></td></tr>
  <% end %>
</table></div>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/BAO3_cordial_milena.pl"} %>
  <% code("perl") do %>
  #/usr/bin/perl

  # Milena Chaîne - 2017-2018
  # commande : perl BAO3_cordial_milena.pl ./sortie_cordial/rubrique_cordial_utf8.txt fichier_patrons.txt numéro_rubrique
  # description : ce programme parcourt un fichier étiqueté par le logiciel Cordial et extrait des patrons morphosyntaxiques prédéfinis dans ce fichier
  # il transforme les données Cordial en deux listes de POS et de tokens
  # à chaque fois qu'il rencontre la POS qui constitue le début d'un motif, il essaie de le compléter et s'il y parvient il envoie le résultat dans un fichier txt
  # données : le fichier de sortie cordial (converti en UTF-8), un fichier txt contenant des patrons (sous forme de regexp) à rechercher par ligne, le numéro de la rubrique
  # résultat : un fichier txt (en UTF-8) contenant les patrons extraits dans le fichier cordial (une occurrence par ligne)

  #-----------------------------------------------------------
  use utf8;
  binmode STDOUT, ":utf8";

  my $test="Syntaxe : perl BAO3_cordial_milena.pl ./sortie_cordial/rubrique_cordial_utf8.txt fichier_patrons.txt numéro_rubrique\n";

  if (@ARGV!=3) {
    die $test;
  }

  open (CORDIAL,"<:encoding(utf-8)", $ARGV[0]);
  open (MOTIF,"<:encoding(utf-8)", $ARGV[1]);

  # on récupère le numéro de rubrique
  my $rubrique = $ARGV[2];

  # on extrait la liste de motifs
  @liste_motif = <MOTIF>;
  print "Liste des motifs recherchés\n";
  print @liste_motif;
  print "\n";

  close MOTIF;

  #-----------------------------------------------------------
  # transformation du fichier Cordial en listes de tokens et de POS
  my @liste_tokens=();
  my @liste_POS=();

  # pour chaque ligne du fichier
  while (my $ligne = <CORDIAL>) {
    #passer à la ligne suivante si la ligne ne correspond à notre schéma TOKEN LEMME POS
    next if ($ligne!~/^[^\t]+\t[^\t]+\t[^\t]+/);
    $ligne =~ s/\r//g;
    #récupérer la ligne
    chomp($ligne);
    #transformer la ligne en liste
    @liste=split(/\t/, $ligne);
    print "TOKEN : $liste[0]\tPOS : $liste[2]\n";
    #rajouter le token (premier élément de la ligne/liste) à la liste globale
    #de même pour la POS
    push(@liste_tokens , $liste[0]);
    push(@liste_POS, $liste[2]);
  }

  close CORDIAL;

  #-----------------------------------------------------------
  # on va créer un fichier différent
  foreach $motif (@liste_motif) {
    chomp ($motif);
    print "MOTIF : $motif\n";
    mkdir $rubrique;
    open($sortie, ">>:encoding(utf-8)", "./$rubrique/$motif.txt")
      || die "Impossible d'ouvrir $motif.txt";

    # transformer le motif en une liste de POS et vérifier le nombre de POS qu'il contient
    my @patron = split(/\#/, $motif);
    my $longueur_patron = scalar @patron;
    my $longueur_liste = scalar @liste_tokens;
    my $sequence = "";
    my $indice_liste = 0;
    my $indice_motif = 0;
    my $decalage = 0;

    # on va passer par chaque ligne/POS de notre fichier
    while ($indice_liste < $longueur_liste) {
      if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
        #on garde en mémoire où on en est dans la liste
        $decalage = $indice_liste;
        #on commence à composer le motif
        $sequence = $sequence.$liste_tokens[$indice_liste];

        # tant qu'il reste des POS à trouver pour compléter le patron
        while ($indice_motif < ($longueur_patron-1)) {
          $indice_liste++;
          $indice_motif++;
          # on cherche la POS suivante
          if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
            $sequence = $sequence." ".$liste_tokens[$indice_liste];
          }
          # si elle ne correspond pas au patron on sort et on se remet à zéro
          else {
            $decalage++;
            $indice_liste = $decalage;
            $sequence = "";
            $indice_motif = 0;
            last;
          }
        }

        # si on a complété un patron on l'imprime
        if ($sequence) {
          print "MOTIF TROUVE : $sequence\n";
          print $sortie "$sequence\n";
        }
        # on se remet à zéro
        $sequence = "";
        $indice_motif = 0;
        $decalage++;
        $indice_liste = $decalage;
      }
      # si la ligne qu'on traite ne correspond pas au début du motif on enchaîne
      else {
        $indice_liste++;
      }
    }
  }
  <% end %>
</label>

<h4 id="treetagger_perl">TREETAGGER ET PERL</h4>

<div class="explication"><p><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Le programme en perl ci-dessous attend trois arguments : le fichier XML contenant les étiquettes Treetagger, un fichier de patrons (sous forme d'expressions régulières) à extraire dans le fichier, et le numéro de la rubrique (pour nommer les fichiers). Son fonctionnement est presque identique au programme traitant la sortie Cordial, à l'exception de l'extraction des termes et des étiquettes, qui se fait directement dans le fichier XML. Le format des patrons est également différent car Treetagger n'utilise pas les mêmes étiquettes que Cordial.</p>
<p>Format du fichier de patrons :</p>
<table style="float:center">
  <% current_page.data.patrons.treetagger.each do |patron| %>
  <tr><td><%= patron %></td></tr>
  <% end %>
</table></div>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/BAO3_treetagger_milena.pl"} %>
  <% code("perl") do %>
  #/usr/bin/perl

  # Milena Chaîne - 2017-2018
  # commande : perl BAO3_treetagger_milena.pl ./sortie_cordial/rubrique_treetagger.xml fichier_patrons.txt numéro_rubrique
  # description : ce programme parcourt le fichier xml contenant des étiquettes treetagger et extrait des patrons morphosyntaxiques prédéfinis dans ce fichier
  # son fonctionnement est très similaire à celui du programme pour Cordial, l'extraction des POS/tokens se fait différemment en fonction de la structure de la ligne
  # données : le fichier XML traité par Treetagger, un fichier txt contenant des patrons (sous forme de regexp) à rechercher par ligne
  # résultat : un fichier txt (en UTF-8) contenant les patrons extraits dans le fichier (une occurrence par ligne)

  #-----------------------------------------------------------
  use utf8;
  binmode STDOUT, ":utf8";

  my $test="Syntaxe : perl BAO3_cordial_milena.pl ./sortie_cordial/rubrique_cordial_utf8.txt fichier_patrons.txt numéro_rubrique\n";

  if (@ARGV!=3) {
    die $test;
  }

  open (TREETAGGER,"<:encoding(utf-8)", $ARGV[0]);
  open (MOTIF,"<:encoding(utf-8)", $ARGV[1]);

  # on récupère le numéro de rubrique
  my $rubrique = $ARGV[2];

  # on extrait la liste de motifs
  @liste_motif = <MOTIF>;
  print "Liste des motifs recherchés\n";
  print @liste_motif;
  print "\n";

  close MOTIF;

  #-----------------------------------------------------------
  # transformation du fichier Treetagger en listes de tokens et de POS
  my @liste_tokens=();
  my @liste_POS=();

  # pour chaque ligne du fichier
  while (my $ligne = <TREETAGGER>) {
    #passer à la ligne suivante si la ligne n'est pas une ligne contenant un token
    next if ($ligne!~/^<element><data type="type">([^>]+)<\/data><data type="lemma">([^>]+)<\/data><data type="string">([^>]+)<\/data><\/element>/);
  	my $pos = $1;
  	my $token = $3;
    print "TOKEN : $token\tPOS : $pos\n";
    #rajouter le token (premier élément de la ligne/liste) à la liste globale
    #de même pour la POS
    push(@liste_tokens , $token);
    push(@liste_POS, $pos);
  }

  close CORDIAL;

  #-----------------------------------------------------------
  # on va créer un fichier différent
  foreach $motif (@liste_motif) {
    chomp ($motif);
    print "MOTIF : $motif\n";
    mkdir $rubrique;
    open($sortie, ">>:encoding(utf-8)", "./$rubrique/TREETAGGER_$motif.txt")
      || die "Impossible d'ouvrir $motif.txt";

    # transformer le motif en une liste de POS et vérifier le nombre de POS qu'il contient
    my @patron = split(/\#/, $motif);
    my $longueur_patron = scalar @patron;
    my $longueur_liste = scalar @liste_tokens;
    my $sequence = "";
    my $indice_liste = 0;
    my $indice_motif = 0;
    my $decalage = 0;

    # on va passer par chaque ligne/POS de notre fichier
    while ($indice_liste < $longueur_liste) {
      if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
        #on garde en mémoire où on en est dans la liste
        $decalage = $indice_liste;
        #on commence à composer le motif
        $sequence = $sequence.$liste_tokens[$indice_liste];

        # tant qu'il reste des POS à trouver pour compléter le patron
        while ($indice_motif < ($longueur_patron-1)) {
          $indice_liste++;
          $indice_motif++;
          # on cherche la POS suivante
          if ($liste_POS[$indice_liste] =~ /$patron[$indice_motif]/) {
            $sequence = $sequence." ".$liste_tokens[$indice_liste];
          }
          # si elle ne correspond pas au patron on sort et on se remet à zéro
          else {
            $decalage++;
            $indice_liste = $decalage;
            $sequence = "";
            $indice_motif = 0;
            last;
          }
        }

        # si on a complété un patron on l'imprime
        if ($sequence) {
          print "MOTIF TROUVE : $sequence\n";
          print $sortie "$sequence\n";
        }
        # on se remet à zéro
        $sequence = "";
        $indice_motif = 0;
        $decalage++;
        $indice_liste = $decalage;
      }
      # si la ligne qu'on traite ne correspond pas au début du motif on enchaîne
      else {
        $indice_liste++;
      }
    }
  }
  <% end %>
</label>

<h4 id="treetagger_xquery">TREETAGGER ET XQUERY</h4>

<h4 id="treetagger_xslt">TREETAGGER ET XSLT</h4>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/xslt/exercice12_2_1.xsl"} %>
  <% code("xml") do %>
  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="1.0">
      <xsl:output method="html" encoding="UTF-8"/>
      <xsl:template match="/">
          <html>
              <body>
                  <h1>Extraction du patron NOM ADJ</h1>
                  <table>
                      <tr>
                          <td>
                              <xsl:apply-templates select="//item"/>
                          </td>
                      </tr>
                  </table>
              </body>
          </html>
      </xsl:template>
      <xsl:template match="item">
                  <xsl:apply-templates select="./titre/document/article/element"/>
      </xsl:template>
      <xsl:template match="element">
          <xsl:choose>
              <xsl:when
                  test="(./data[contains(text(), 'NOM')]) and (following-sibling::element[1][./data[contains(text(), 'ADJ')]])">
                  <xsl:value-of select="./data[3]"/>
                  <xsl:text> </xsl:text>
              </xsl:when>
              <xsl:when
                  test="(./data[contains(text(), 'ADJ')]) and (preceding-sibling::element[1][./data[contains(text(), 'NOM')]])">
                  <xsl:value-of select="./data[3]"/>
                  <xsl:text>&#xA;</xsl:text>
              </xsl:when>
          </xsl:choose>
      </xsl:template>
  </xsl:stylesheet>

  <% end %>
</label>

<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/xslt/exercice12_2_2.xsl"} %>
  <% code("xml") do %>
  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="1.0">
      <xsl:output method="text" encoding="utf-8"/>
      <xsl:template match="/">
          <html>
              <body>
                  <h1>Extraction du patron DET:ART NOM NAM</h1>
                  <table>
                      <tr>
                          <td>
                              <xsl:apply-templates select="//item"/>
                          </td>
                      </tr>
                  </table>
              </body>
          </html>
      </xsl:template>
      <xsl:template match="item">
                  <xsl:apply-templates select="./titre/document/article"/>
      </xsl:template>
      <xsl:template match="article">
          <xsl:for-each select="element">
              <xsl:if test="(./data[1][contains(text(), 'DET:ART')])">
                  <xsl:variable name="a" select="./data[3]/text()"/>
                  <xsl:if test="following-sibling::element[1][./data[1][contains(text(), 'NOM')]]">
                      <xsl:variable name="b" select="following-sibling::element[1]/data[3]/text()"/>
                      <xsl:if test="following-sibling::element[2][./data[1][contains(text(), 'NAM')]]">
                          <xsl:variable name="c" select="following-sibling::element[2]/data[3]/text()"/>
                          <xsl:value-of select="$a"/>
                          <xsl:text> </xsl:text>
                          <xsl:value-of select="$b"/>
                          <xsl:text> </xsl:text>
                          <xsl:value-of select="$c"/>
                          <xsl:text>&#xA;</xsl:text>
                      </xsl:if>
                  </xsl:if>
              </xsl:if>
          </xsl:for-each>
      </xsl:template>
  </xsl:stylesheet>

  <% end %>
</label>
<label>
  <%= partial "partials/code", :locals => { :code_file => "assets/milena/xslt/exercice12_2_3.xsl"} %>
  <% code("xml") do %>
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="html" encoding="utf-8"/>
    <xsl:template match="/">
        <html>
            <body>
                <h1>Extraction du patron VER:infi DET:ART NOM ADJ</h1>
                <table>
                    <tr>
                        <td>
                            <xsl:apply-templates select="//item"/>
                        </td>
                    </tr>
                </table>
            </body>
        </html>
        <xsl:apply-templates select=".//article"/>
    </xsl:template>
    <xsl:template match="item">
        <xsl:apply-templates select="./titre/document/article"/>
    </xsl:template>

    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(), 'VER:infi')])">
                <xsl:variable name="a" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(), 'DET:ART')]]">
                    <xsl:variable name="b" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(), 'NOM')]]">
                        <xsl:variable name="c" select="following-sibling::element[2]/data[3]/text()"/>
                        <xsl:if
                            test="following-sibling::element[3][./data[1][contains(text(), 'ADJ')]]">
                            <xsl:variable name="d"
                                select="following-sibling::element[3]/data[3]/text()"/>
                            <xsl:value-of select="$a"/>
                            <xsl:text> </xsl:text>
                            <xsl:value-of select="$b"/>
                            <xsl:text> </xsl:text>
                            <xsl:value-of select="$c"/>
                            <xsl:text> </xsl:text>
                            <xsl:value-of select="$d"/>
                            <xsl:text>&#xA;</xsl:text>
                        </xsl:if>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>

    </xsl:template>

</xsl:stylesheet>
<% end %>
</label>
<div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Vous trouverez dans ce tableau l'intégralité des résultats obtenus, au format TXT et HTML. Ils sont classés par motif, puis par étiqueteur afin de pouvoir comparer les résultats plus facilement.</p></div>

<div class= "tableau"><table style="float:center">
  <tr>
    <th colspan="2">Motifs</th>
    <th>Rubrique 3210 (International)</th>
    <th>Rubrique 3214 (Europe)</th>
    <th>Rubrique 3224 (Société)</th>
  </tr>
  <tr>
  <th rowspan="2">DETERMINANT - NOM COMMUN - NOM PROPRE</th>
  <td>Cordial</td>
  <td>TXT</td>
  <td>TXT</td>
  <td>TXT</td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
  </tr>
  <tr>
  <th rowspan="2">DETERMINANT - NOM COMMUN - DETERMINANT - NOM PROPRE</th>
  <td>Cordial</td>
  <td>TXT</td>
  <td>TXT</td>
  <td>TXT</td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
  </tr>
  <tr>
  <th rowspan="2">VERBE (INFINITIF) - DETERMINANT - NOM</th>
  <td>Cordial</td>
  <td>TXT</td>
  <td>TXT</td>
  <td>TXT</td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
  </tr>
  <th rowspan="2">VERBE (INFINITIF) - DETERMINANT - NOM - ADJECTIF</th>
  <td>Cordial</td>
  <td>TXT</td>
  <td>TXT</td>
  <td>TXT</td>
  </tr>
  <tr>
    <td>Treetagger</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
    <td>TXT, HTML</td>
  </tr>
</table></div>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>

<%= partial "partials/h3", :locals => { :raccourci => "bao4", :titre => "Boîte à outils 4 : création de graphes"} %>
<%= partial "partials/onglets_milena" %>

<%= image_tag 'schema/bao_schema_4.png' %>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>


<%= partial "partials/h3", :locals => { :raccourci => "conclu", :titre => "Conclusion et analyse"} %>
<%= partial "partials/onglets_milena" %>

<p>bip bop</p>
